# 📍 메모리 관리 기법

## 연속 메모리 관리 기법

- 프로그램 전체가 메모리에 연속적으로 할당되어야하는 관리 기법
- `고정 분할 기법` : 메모리가 고정된 파티션으로 분할, 내부 단편화 발생
- `동적 분할 기법` : 파티션들이 동적 생성, 자신의 크기와 같은 파티션에 적재, 외부 단편화 발생

<br>

## 불연속 메모리 관리 기법

- 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법
- `Page` : 프로세스를 고정된 크기의 작은 블록들로 나누었을 때, 그 블록들을 `페이지`라고 한다.
- `Frame` : 페이지 크기와 같은 주기억장치의 메모리 블럭
- `Segment` : 서로 다른 크기의 논리적 단위


<br><br>

# 📍 메모리 단편화 (Memory Fragmentation)

컴퓨터에서 어떤 프로그램을 실행할 때 메모리의 공간을 연속적인 형태로 할당하여 사용하게 되는데, 이 과정에서 메모리 공간이 조각조각 나뉘어 실제로는 사용 가능한 메모리가 충분하지만 할당이 불가능해진 상태

<br>

## 내부 단편화 (Internal Fragmentation)

![image](https://user-images.githubusercontent.com/78673570/194753096-da37e42a-d295-4246-9813-a2defd537bd2.png)

- 주기억장치 내 사용자 영역이 실행 프로그램보다 커서 프로그램의 사용 공간을 할당 후 사용되지 않고 남게 되는 현상
- 적은 크기의 잔여 메모리가 발생해 해당 메모리를 사용할 수 없게 되는 현상

<br>

## 외부 단편화 (External Fragmentation)

![image](https://user-images.githubusercontent.com/78673570/194753252-9044e6be-271b-4201-92ed-216633f02700.png)

- 남아있는 총 메모리 공간이 요청한 메모리 공간보다 크지만, 남아있는 공간이 연속적(contiguous)이지 않아 발생하는 현상

<br><br>

# 📍 메모리 단편화 해결 방법

## 페이징 (Paging)

![image](https://user-images.githubusercontent.com/78673570/194753307-f8893c0d-9306-430b-b768-af792a1f6287.png)

- 프로세스를 `일정한 크기의 페이지`로 분할해서 메모리에 적재하는 방식 (페이지 : 고정 크기)
- 프로세스가 바라보는 메모리 주소 공간(= 논리 주소)와 실제 메모리 주소 공간(= 물리 주소)를 구분한다. 
    - 실제 메모리는 연속적이지 않지만, 논리 주소와 물리 주소를 나누어 사용함으로써 CPU는 메모리를 연속적으로 사용하고 있다는 것을 보장받으며 정상적으로 작업을 수행할 수 있다. 
    - 외부 단편화는 떨어져있는 잔여 공간을 `압축`하여 해결할 수 있는데, 이 작업을 해소할 수 있다.
- 외부 단편화가 발생하지 않는 방법이다.
- 페이지가 클 수록, 내부 단편화가 발생할 가능성이 높아진다.

<br>

## 세그먼테이션 (Segmentation)

![image](https://user-images.githubusercontent.com/78673570/194753494-14d14517-47e5-4fd4-b622-24f17b87cbcb.png)

- 페이징 기법과 다르게 논리적 단위인 `세그먼트` 단위로 분할하여 메모리에 적재하는 방식 (세그먼트 : 가변 크기)
- 논리적 단위로 나뉘기 때문에 미리 분할을 해두는 것이 아니고, 메모리를 사용하는 시점에 할당된다.
- 내부 단편화가 발생하지 않는 방법이다.
- 외부 단편화가 발생할 가능성이 있다.
