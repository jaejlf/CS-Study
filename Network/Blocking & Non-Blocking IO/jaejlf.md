# 📍 Blocking I/O

```sql
1. 사용자 프로세스가 커널에게 I/O를 요청하는 recvfrom() 함수 호출한다.
2. 커널이 작업을 완료하면 작업 결과를 반환한다.
3. I/O 작업이 진행되는 동안 사용자 프로세스는 자신의 작업을 중단한 채 대기한다.
```

- I/O작업이 진행되는 동안 사용자 프로세스가 자신의 작업을 `중단`한채, I/O가 끝날때까지 `대기`하는 방식
- I/O가 호출되면 제어권을 가져가서 어플리케이션이 멈춘다.
- 특징
  - Resource 낭비가 심하다.
- 여러 클라이언트가 접속하는 서버를 Blocking I/O 방식으로 구현하는 경우
  - 다른 클라이언트가 진행 중인 작업을 중지하면 안되므로, 클라이언트별로 별로도 스레드를 생성해야한다.
  - 접속자 수가 많아질 경우 -> 이로 인해 많아진 스레드로 컨텍스트 스위칭 횟수가 증가하여 비효율적이다.
 
<br><br>

# 📍 Non-Blocking I/O

```sql
1. 사용자 프로세스가 커널에게 I/O를 요청하는 recvfrom() 함수 호출한다.
2. 커널은 이 요청에 대해서, 곧바로 recvBuffer를 채워서 보내지 못하므로, "EWOULDBLOCK"을 반환한다.
3. recvBuffer에 사용자가 받을 수 있는 데이터가 있는 경우, Buffer로부터 빠른 속도로 데이터를 복사한 후 데이터의 길이와 함께 반환한다.
   (이때, recvBuffer는 커널이 아니라 가지고 있는 메모리에 적재되어 있으므로, 메모리간 복사로 인해 I/O보다 훨씬 빠른 속도로 데이터를 받아올 수 있다.)
```

- I/O 작업이 진행되는 동안 User Process의 작업을 `중단하지 않는` 방식
- I/O가 호출되면 결과를 즉시 리턴하고, I/O가 완료될 때까지 `대기하지 않는다`
- 제어권을 어플리케이션이 가지고 어플리케이션은 계속 동작한다.


.
<br>
.
<br>

💡 EWOULDBLOCK : 논블로킹 모드에서 자원 사용이 불가능한 경우 발생하는 에러
