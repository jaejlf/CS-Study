# 💡 저장 프로시저(Stored Procedure)

저장 프로시저란 "**일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합**"을 말하며, 자주 사용되는 복잡한 작업들을 하나의 요청으로 간단하게 실행할 수 있다.

<br/>

> #### Q. 저장 함수 (Stored Function) 와는 어떤 차이가 있을까?
> 저장 함수와 저장 프로시저는 거의 비슷하다.
> 
> 다만, 저장 함수는 리턴값이 필수이고, 저장 프로시저는 있을 수도 있고, 없을 수도 있다는 점에서 차이가 있다. (저장 프로시저에서도 OUT이나 INOUT을 사용하면 리턴값을 가질 수 있다.)

<br/> 

## 매개변수 (IN, OUT, INOUT)

저장 프로시저의 매개변수에는 3가지 모드가 존재한다.

- `IN` : 프로시저에 값을 전달하며, 프로시저 내부에서 값을 수정할 수는 있지만 프로시저가 반환되고나서 호출자가 수정할 수는 없다. 즉, 저장 프로시저는 IN 매개변수의 복사본만을 사용한다.
- `OUT` : 프로시저의 값을 호출자에게 다시 전달한다. 초기값은 프로시저 내에서 NULL값이며 프로시저가 반환될 때 새로운 값이 호출자에게 리턴된다.
- `INOUT` : 호출자에 의해 하나의 변수가 초기화되고 프로시저에 의해 수정된다. 프로시저가 리턴할 때 프로시저가 변경한 사항은 호출자에게 리턴된다.

<br/>

## 사용법

### 1. 생성 (정의)

PL/SQL (ORACLE)

```sql
CREATE PROCEDURE [프로시저 이름] ([매개변수 이름] [IN|OUT|INOUT] [타입], ...)
  IS
     [변수 선언]
  BEGIN
     [실행문]
  END;
  /
```
- Oracle에서 `/` 기호는 프로시저를 끝마칠 때 사용한다.


MySQL
```sql
DELIMITER // 	-- 마침 기호 변경
CREATE PROCEDURE [프로시저 이름] ([매개변수 이름] [IN|OUT|INOUT] [타입], ...)
BEGIN 
    [실행문]
END //
DELIMITER ;	-- 마침기호 취소
```

<br/>

### 2. 실행 (호출)

PL/SQL (ORACLE)
```sql
EXECUTE [프로시저 이름];
```

MySQL

```sql
CALL [프로시저 이름];
```

<br/>

### 3. 삭제
```sql
DROP PROCEDURE [프로시저 이름];
```

<br/>

### 예제

```sql
CREATE OR REPLACE PROCEDURE printName( name IN VARCHAR2 ) 
  IS
      msg VARCHAR2(5) := '내 이름은';
  BEGIN 
      dbms_output.put_line(msg||' '||name); 
  END;
  /

EXEC printName('wisdom');
```

```
내 이름은 wisdom
```

<br/> 

## 동작 방식

그렇다면 일반적인 SQL문과 어떻게 다른지 동작 방식을 통해 알아보자.

<br/>

### 1. 일반적인 SQL문 동작 방식

일반적인 SQL문을 실행하면 다음과 같은 프로세스로 동작한다.

<br/>
<img width="50%"
     src="https://user-images.githubusercontent.com/75151848/195842598-d9dc5e68-0877-4094-a2db-9a92adbba353.png"/>
<br/>

1. 구문 분석 : 구문 자체에 오류가 없는지 분석한다.
2. 개체 이름 확인 : SQL문의 테이블과 컬럼이 현재 데이터베이스에 있는지 확인한다.
3. 사용권한 확인 : 사용자가 해당 테이블에 대한 권한이 있는지 확인한다.
4. 최적화 : 쿼리문이 가장 좋은 성능을 낼 수 있는 경로를 결정한다.
5. 컴파일 및 실행 계획 등록 : 최적화된 결과를 바탕으로 실행 계획 결과를 캐시에 등록한다.
6. 실행 : 컴파일된 결과를 실행한다.

<br/>

만약 캐시에 동일한 쿼리가 있다면(한 글자도 틀리지 않고 같다면) 아래와 같이 동작하여 시간이 단축된다. 

<br/>
<img width="50%"
     src="https://user-images.githubusercontent.com/75151848/195843594-ab7de172-c197-42d4-a0a0-d545a4a3d089.png"/>
<br/>

### 2. 저장 프로시저 동작 방식

#### 저장 프로시저 생성

<br/>
<img width="50%"
     src="https://user-images.githubusercontent.com/75151848/195844187-697427f9-310e-4cdd-b9a9-035ca6f34b37.png"/>
<br/>

1. 구문 분석 : 구문 오류가 있는지 확인한다.
2. 지연된 이름 확인 : 지연된 이름 확인(deferred name resolution) 과정을 거친다. 저장 프로시저의 경우에는 프로시저를 정의하는 시점에 테이블과 같은 해당 개체의 존재 여부와 상관없이 정의가 가능하다. 이는 프로시저의 실행 시점이 되어서야 해당 테이블의 존재 여부를 확인하기 때문이다.
3. 생성 권한 확인 : 사용자가 저장 프로시저를 생성할 권한이 있는지를 확인한다.
4. 시스템 테이블에 등록 : 저장 프로시저의 이름과 코드를 관련 시스템 테이블에 등록한다.

<br/>

#### 첫 번째 실행
<br/>
<img width="50%"
     src="https://user-images.githubusercontent.com/75151848/195844211-f067a19e-2afb-4fd7-9670-92c7e37c1b1f.png"/>
<br/>

저장 프로시저를 처음으로 실행했을 때의 동작은 일반적인 쿼리와 비슷하다.

다만, 저장 프로시저 생성 시에 구문 분석을 했기 때문에 여기서는 구문 분석을 하지 않는다.

<br/>

#### 이후 실행
<br/>
<img width="50%"
     src="https://user-images.githubusercontent.com/75151848/195844225-ad0ee2eb-e494-464a-a941-3ce1cfedb32e.png"/>
<br/>

두 번째 실행부터는 캐시에 있는 것을 그대로 가져와 재사용하므로, 수행시간이 많이 단축된다.

따라서 자주 쓰는 쿼리라면 일반적인 쿼리를 날리는 것보다 성능적인 측면에서 이득을 볼 수 있다!

<br/> 

## 장점

### 1. 최적화 & 캐시 (성능 향상)
저장 프로시저를 최초로 실행하면 최적화 상태로 컴파일이 되며, 그 결과가 프로시저 캐시에 저장된다.

만약 해당 프로세스가 여러 번 사용될 때, 다시 컴파일 작업을 거치지 않고 캐시에 있는 것을 가져와 사용하므로 실행속도가 빨라진다.
따라서 일반 쿼리를 반복해서 실행하는 것보다 저장 프로시저를 사용하는 것이 성능적인 측면에서 좋다.


### 2. 유지보수

응용 프로그램에서 직접 SQL문을 호출하지 않고 저장 프로시저의 이름을 호출하도록 설정하면, 수정 사항이 발생할 때 코드 내 SQL문을 건드리지 않고 저장 프로시저 파일만 수정하면 되기 때문에 유지보수 측면에서 유리하다.

또한 저장 프로시저는 한 번 생성해놓으면, 언제든지 실행할 수 있기 때문에 재활용하기 좋다.

### 3. 트래픽 감소

클라이언트에서 SQL문의 모든 텍스트를 전송하지 않고, 저장 프로시저의 이름과 매개변수만 서버로 전송하기 때문에 네트워크 부하를 크게 줄일 수 있다.

### 4. 보안 강화

사용자별로 테이블에 권한을 주는게 아닌 저장 프로시저에만 접근 권한을 주는 방식으로 보안을 강화할 수 있다.

실제 테이블에 접근하여 다양한 조작을 하는 것은 위험하기 때문에 실무에서는 실제로 개발자에게는 저장 프로시저 권한만 주는 방식을 많이 사용한다.

<br/> 

## 단점

### 1. 호환성

구문 규칙이 SQL/PSM 표준과의 호환성이 낮기 때문에 코드 자산으로의 재사용성이 나쁘다.

> 🤔 SQL/PSM 이란?
> 
> 주로 저장 프로시저에 사용하기 위해 절차적 언어로 SQL 확장을 정의해둔 ISO 표준.

### 2. 성능

문자 또는 숫자 연산에서 프로그래밍 언어인 C나 Java보다 성능이 느리다.

### 3. 디버깅

에러가 발생했을 때, 어디서 잘못됐는지 디버깅하는 것이 힘들 수 있다.

<br/><br/>


## 🔖 참고
- [저장 프로시저(Stored PROCEDURE)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/%EC%A0%80%EC%9E%A5%20%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80(Stored%20PROCEDURE).md)
- [블로그](https://devkingdom.tistory.com/323)
- [블로그](https://prinha.tistory.com/entry/MySQL-%EC%A0%80%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80%EC%9D%98-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-IN-OUT-INOUT)
