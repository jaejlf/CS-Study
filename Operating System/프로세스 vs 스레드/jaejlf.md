# 📍 프로그램

  -  어떤 작업을 위해 실행할 수 있는 파일
  -  명령어, 코드 등 정적인 데이터의 묶음
  -  파일이 저장 장치에 저장되어 있지만 메모리에는 올라가 있지 않은 상태

<br><br>

# 📍 프로세스

- 실행 중인 프로그램
- 운영체제로부터 시스템 자원을 할당받는 작업의 단위
- 프로그램을 실행하면 운영체제로부터 실행에 필요한 자원을 할당받아 `프로세스`가 된다.
- 프로세스가 할당받는 시스템 자원 : CPU 시간, 주소 공간, 메모리 영역 등
- 프로세스는 최소 한 개 이상의 스레드를 가지며, 이 스레드를 `메인 스레드(main thread)`라고 한다.

<br>
  
💡 프로세서 (Processor) = 프로세스를 실행할 수 있도록 하는 하드웨어 (ex. CPU)

<br>

## 특징

- 프로세스는  `Code, Data, Stack, Heap`의 구조로 되어있는 독립된 메모리 영역을 할당받는다.
- 각 프로세스는 `독립적`이다.
  - 각 프로세스는 별도의 주소 공간에서 실행된다.
  - 서로 독자적인 메모리 공간을 갖기 때문에, 메모리 공간을 공유할 수 없다. 즉, 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
- `IPC(Inter-Process Communication, 프로세스 간 통신)`를 사용해 통신한다.

<br>

## 관련 개념

### 프로세스의 구조

cf. [프로세스 주소 공간](https://github.com/jaejlf/CS-Study/blob/main/Operating%20System/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EC%A3%BC%EC%86%8C%20%EA%B3%B5%EA%B0%84/jaejlf.md)

<br>

### 프로세스의 상태 변화

![image](https://user-images.githubusercontent.com/78673570/183588057-862f9321-5015-4a07-a3a4-bdb69c0532f9.png)


status | work
:--: | --
생성 | - 프로세스가 메모리에 올라와 실행 준비를 완료한상태 <br> - PCB 생성
준비 | - 실행 준비가 되어 CPU 할당을 기다리는 상태 <br> - 준비된 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일은 CPU 스케쥴러가 담당 <br> - `Dispatch` : 준비 → 실행 상태로 바꾸는 CPU 스케쥴러의 작업 <br> - `Timeout` : 프로세스에 배당된 작업 시간 내에 작업을 끝내지 못해 다시 준비 상태로 돌아가는 것 (clock으로부터의 인터럽트)
실행 | - 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태 <br> - 프로세스에 배당된 작업 시간동안 작업
대기 | - 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태 <br> - 입출력장치별로 마련된 큐에서 대기
완료 | - 실행 상태의 프로세스가 주어진 시간 내에 작업을 마친 상태 <br> - PCB 제거 <br> - `코어 덤프(core dump)` : 강제 종료를 만나면 디버깅하기 위해 강제 종료 직전의 메모리 상태를 저장장치로 옮기는 것

<br>

### PCB (Process Control Block)

![image](https://user-images.githubusercontent.com/78673570/183588074-5edfb59c-c18c-4b76-b578-e03534bc1db2.png)

- 프로세스 제어 블럭
- 프로세스의 제어를 위한 정보를 포함하고 있는 자료구조
- 운영체제가 프로세스 스케쥴링을 위한 정보를 가지고 있는 것
- 프로세스가 생성될 때마다 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거된다.
- PCB에 들어있는 정보
  1. `포인터` : 프로세스의 현재 위치를 저장하는 포인터 정보
  2. `프로세스 상태` : 프로세스의 각 상태(생성/준비/실행/대기/종료)
  3. `프로세스 번호` : 모든 프로세스에는 프로세스 식별자를 지정하는 고유한 ID(= PID)
  4. `프로그램 카운터` : 프로세스를 위해 실행될 다음 명령어의 주소를 포함하는 카운터
  5. `레지스터` : CPU 레지스터에 있는 정보
  6. `메모리 제한` : 운영체제에서 사용하는 메모리 관리 시스템에 대한 정보 (페이지 테이블, 세그먼트 테이블 등)
  7. `열린 파일 목록` : 프로세스를 위해 열린 파일 목록

<br><br>

# 📍 스레드

- 프로세스가 할당받는 자원을 이용하는 실행 단위
- 프로세스의 특정한 수행 경로
- 프로세스 내에서 실행되는 여러 작업 흐름의 단위
- 프로세스가 운영체제로부터 자원을 할당받으면 그 자원을 스레드가 사용하여 실제로 작업을 수행한다.

<br>

## 특징

- 각 스레드는 `독립적인 스택(Stack) 메모리`를 갖는다.
- 스레드는 프로세스 내에서 각각의 스택만 할당받고, `Code, Data, Heap 영역은 공유`한다.
- 스레드는 메모리를 공유하기 때문에 `동기화`, `데드락` 등의 문제가 발생할 수 있다.

<br><br>

# 📍 멀티 프로세싱 vs 멀티 스레딩

## 멀티 프로세싱

- 하나의 프로그램을 여러 개의 프로세스로 구성하여, 각 프로세스가 하나의 작업을 처리하도록 하는 것
- 특징
  - `각 프로세스는 독립적이다.`
    - 여러 개의 자식 프로세스 중 하나에 문제가 발생하더라도, 다른 프로세스들에 영향을 주지 않는다.
    - 동기화 작업이 필요하지 않다.
    - 자원이 소모적이고 개별 메모리를 차지한다.
    - IPC를 사용한 통신 기법으로 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에, 프로세스 사이의 변수나 자료구조를 공유할 수 없다.
  - `Context Switching 비용이 크다`
    - Context Switching 이 발생하면 캐시의 모든 데이터를 리셋하고 다시 캐시 정보를 불러와야하기 때문에 무거운 작업이 진행되고 많은 시간이 소모된다.

<br>

### 프로세스의 동시성 vs 병렬성

![image](https://user-images.githubusercontent.com/78673570/183588090-23a23616-520e-4e97-9433-9573e366dd08.png)

동시성(Concurrency) | 병렬성(Parallelism)
-- | --
동시에 실행되는 것 같이 "보이도록" 처리하는 것 | "실제로 동시에" 여러 작업이 처리되는 것
"싱글 코어"에서 멀티 스레드를 동작 시키는 방식 | "멀티 코어"에서 멀티 스레드를 동작시키는 것 

<br>

## 멀티 스레딩

- 하나의 프로세스를 여러 개의 실행 단위로 나누어, 동시에 여러 개의 일을 수행할 수 있도록 하는 것
- 특징
  - `각 스레드는 긴밀하게 연결되어 있다.`
    - 자원을 공유하기 때문에 자원을 효율적으로 관리할 수 있다.
    - 스택 영역을 제외한 모든 메모리를 공유하기 때문에, 통신의 부담이 적고 시스템 자원 소모가 줄어든다.
    - 공유되는 자원을 관리해주어야한다. 
    - 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.
   - `Context Switching 비용이 작다.`
      - 스레드 사이의 작업량이 작아 Context Switching 이 빠르다. 
   - `동기화 & 데드락 문제`
