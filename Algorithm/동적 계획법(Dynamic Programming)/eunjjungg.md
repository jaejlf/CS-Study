# 1. 동적 계획법

- 하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용함.
- 큰 문제를 작은 문제로 쪼개서 그 답을 저장하고 다시 재활용하는 방식임.
- 일반적인 재귀를 사용하면 동일한 작은 문제들이 여러번 반복되어 비효율적인 계산이 될 수 있기에 동적 계획법을 사용하게 됨.

<br/><br/>
  
# 2. DP의 사용 조건

1. Overlapping Subproblems : 겹치는 부분 문제
    1. 동일한 작은 문제들이 반복하여 나타나는 경우에 사용 가능함. 왜냐하면 작은 문제들의 값을 저장하고 재사용하는 것이 DP의 기능이기 때문. 
2. Optimal Substructure : 최적 부분 구조 
    1. 부분 문제의 결과 값을 사용해 구한 전체 문제의 결과와 원래 문제의 결과 값이 동일한 구조일 때 사용 가능. 

  <br/><br/>
  
# 3. 구현 방법

1. Bottop - up 방식 
    1. 아래에서부터 계산을 수행하고 누적시켜서 전체 큰 문제를 해결하는 방식. Bottom up 방식으로 구현할 때는 Memoization 대신 Tabulation을 사용했다고 함. 왜냐하면 dp[0] → dp[1] → … dp[n] 순서로 값을 차례차례 구해나가는 상황인데 하나씩 채우는걸 table-filling이라고 하고 이 테이블에 직접 접근하여 값을 재활용하기 때문에 Tabulation이라는 명칭을 사용
2. Top - down 방식
    1. Bottom-up의 dp[0]부터 수행하여 dp[n]의 값을 구하기 위해 올라가는 거 대신 바로 dp[n]부터 호출하여 dp[0]의 상태까지 내려간 다음 재귀를 통해 전이시켜 값을 재활용하는 방식. 이후에 dp[k]의 값을 구한다고 할 때 이미 계산을 완료한 값인 경우에는 저장되어 있던 내역을 재사용함. 따라서 Memoization이라고 불림. 

  <br/><br/>
  
# 4. 분할 정복과의 차이점

분할 정복과 동적 프로그래밍 모두 주어진 문제를 작게 쪼개 하위 문제로 해결한다는 점에서는 같지만 분할 정복은 하위 문제가 동일하게 중복이 일어나는 경우에는 사용하지 않고 여기에는 동적 프로그래밍을 사용함.
