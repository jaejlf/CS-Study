# TCP-IP 흐름제어 & 혼잡 제어

## A. 복습

TCP란?

## B. TCP 흐름 제어

- 흐름 제어(endsystem 대 endsystem)

> 송신 측과 수신 측의 데이터 처리 속도 차이를 해결하기 위한 기법

→ 송신 측의 속도가 빠를 때 문제가 된다
→ 수신 측에서 제한한 용량을 초과한 이후 도착한 데이터는 손실될 수 있으며, 이 경우 불필요한 응답/데이터 전송이 발생할 수 있다<br>
→ 이러한 위험 방지 위해 **송신 측의 데이터 전송량을 수신 측에 맞게 조절**해야 한다.

<br>

#### 데이터 전송 과정

네트워크로 데이터를 전송하는 과정은 다음과 같다.

송신 측이 소켓에 데이터 작성 → 전송 계층(이 경우에는 TCP프로토콜)이 헤더를 붙여 세그먼트로 만든 후 네트워크 계층(ex. IP) 으로 전달 → ...(생략) → 수신 측 받아봄

이 과정에서 송신 측이 보낸 순서대로 데이터를 받는 것이 중요.

<br>

<img src="https://www.brianstorti.com/assets/images/tcp-flow-control/buffers.png">

TCP는 전송해야 하는 데이터를 전송 버퍼(send buffer)에 저장하고, 수신받을 데이터를 수신 버퍼(receive buffer)에 저장한다.

애플리케이션이 동작하면 수신 버퍼에서 데이터를 읽는다.<br>
=> 혼잡 제어는 receive buffer의 할당량이 초과한 후에도 패킷이 전달되어 유실되는 패킷이 없도록 데이터 전송량을 조절한다

<br>

### 사용 기법

#### 1) Stop And Wait

: 매번 전송한 패킷에 대해 확인 응답(ACK)을 받아야만 다음 패킷을 전송하는 기법

→ 구현이 간단하긴 하나 패킷을 하나씩만 보내기 때문에 비효율적이다

<img src="https://media.geeksforgeeks.org/wp-content/uploads/Stop-and-Wait-ARQ.png" height=200>

<br>

#### 2) Sliding Window

: **수신 측에서 설정한 윈도우 크기**만큼 **송신 측에서 확인 응답 없이 세그먼트를 전송**할 수 있게 하여 데이터 흐름을 동적으로 조절하는 기법

TCP/IP를 사용하는 호스트들은 송신을 위한 Window와 수신을 위한 Window를 가지고 있다.

송신 측에서는 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는 대로 이 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송한다.

<br>

<img src="https://t1.daumcdn.net/cfile/tistory/253F7E485715ED5F27">

<br>

## C. TCP 혼잡 제어(Congestion Control)

<br>

> 송신 측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법

혼잡: 네트워크 내에 패킷의 수가 과도하게 증가하는 현상

혼잡 현상을 방지하거나 제거하는 기능을 **혼잡제어**라고 한다.

송신 측에서 보내는 데이터의 양이 라우터가 처리할 수 있는 양을 초과하여 초과된 데이터를 라우터가 처리하지 못하면, 송신 측은 초과된 데이터를 손실 데이터로 간주하고 계속 재전송하여 네트워크를 더욱 혼잡하게 한다.

이런 상황을 예방하기 위해 **송신 측의 전송 속도를 적절히 조절**하는 것을 혼잡 제어라고 한다.

<비교>

- 흐름 제어: 송신 측과 수신 측의 전송속도
- 혼잡 제어: 호스트와 라우터를 포함한 보다 넓은 과점에서 전송 문제 다룸

<br>

### 혼잡 윈도우(Congestion Window, CWND)

송신 측의 윈도우 크기는 수신 측이 보내준 윈도우 크기와 네트워크 상황을 함께 고려해서 정해진다.

송신 측은 자신의 최종 윈도우 크기를 정할 떄 수신 측이 보내준 윈도우 크기인 `수신 윈도우(rwnd, receiving window)`, 그리고 자신이 네트워크 상황을 고려해 정한 윈도우 크기인 `혼잡 윈도우(cwnd, congestion window)` 중 더 작은 값을 사용한다.

<br>

### 해결 방법

<br>

#### 1) AIMD(Additive Inctrease/ Multiplicative Decrease)

: 처음에 패킷을 하나씩 보내고, 문제 없이 도착하면 윈도우의 크기를 1씩 증가시키면서 전송. 전송에 실패하면 윈도우 크기를 반으로 줄임.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdtMw6l%2FbtrbWdm4XXz%2FGw3tbyM46xFX3IyqTGnrBk%2Fimg.png" height=150>

<br>

- (장점): 공평한 방식으로, 여러 호스트가 한 네트워크 공유 시 나중에 진입하는 쪽이 처음에는 불리하지만 시간이 흐르면 평형 상태로 수렴하게 된다.
- (단점): 윈도우 크기를 너무 조금씩 증가시키기 때문에 네트워크의 모든 대역을 활용하여 빠른 속도로 통신하기까지 시간이 너무 오래 걸린다.

<br>

#### 2) 느린 시작(Slow Start)

: 윈도우의 크기를 1,2,4,8과 같이 지수적으로 증가시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄인다. 그 이후 혼잡 현상이 발생하면, 혼잡 현상이 발생했던 윈도우 크기의 절반까지는 이전처럼 지수 함수꼴로 창 크기를 증가시키고, 그 이후부터는 완만하게 1씩 증가시킨다.

<img src="https://www.researchgate.net/profile/Drghassan-Abed/publication/256868797/figure/fig1/AS:297662294315010@1447979629987/TCP-Slow-Start-and-Congestion-Avoidance-phase.png" height=150>

<br>

- (장점): 보낸 데이터의 ACK가 도착할 때마다 윈도우 크기를 증가시키기 때문에 처음에는 윈도우 크기가 조금 느리게 증가하더라도, 시간이 갈수록 윈도우 크기가 점점 빠르게 증가한다.
- (장점): 한 번 혼잡현상이 발생하면, 네트워크의 수용량을 예상할 수 있다.

+) 임계점(Threshold)란?
여기까지만 Slow Start를 사용하겠다는 의미를 가진다. Slow Start Threshold(ssthresh)라고도 한다.

<br>

#### 3) 빠른 재전송(Fast Retransmit)

: 패킷을 받는 수신자 입장에서는 패킷이 순서대로 도착하지 않을 수 있는데, 이때 수신 측에서 순서대로 잘 도착한 마지막 패킷의 다음 순번을 ACK 패킷에 실어서 보낸다. 이런 중복 ACK를 3개 받으면 송신 측에서는 자신이 설정한 타임 아웃 시간이 지나지 않아도 바로 해당 패킷을 재전송할 수 있기 때문에 빠른 재전송률을 유지할 수 있다.

#### 4) Fast Recovery

: 혼잡한 상태가 되면 윈도우 크기를 1로 줄이지 않고, 반으로 줄이고 선형 증가시키는 방법이다.

### TCP 혼잡 제어 정책

공통적으로 혼잡이 발생하면 윈도우 크기를 줄이거나, 혹은 증가시키지 않으며 혼잡을 회피한다.

대표적인 정책: `Tahoe`, `Reno`

처음에는 Slow Start 방식을 사용하다가 네트워크가 혼잡하다 느낄 때는 AIMD 방식으로 전환한다.

- Tahoe: Slow Start를 사용하여 자신의 윈도우 크기를 지수적으로 빠르게 증가시키다가 ssthresh를 만난 이후부터는 AIMD에서 사용하는 합 증가 방식을 사용하여 선형적으로 윈도우 크기를 증가. ACK Duplicated나 Timeout이 발생하면 네트워크에 혼잡이 생겼다고 판단, ssthresh 크기 수정

- Reno: Tahoe와 비슷한 방식으로 보이지만 `3 ACK Duplicated`와 `Timeout` 구분. `3 ACK Duplicated` 발생 시 윈도우 크기를 1이 아닌 AMID처럼 반으로 줄이고 sshthresh를 줄어든 윈도우 값으로 정하게 된다.

## D. 정리

### Q1. 흐름 제어란 무엇이고, 사용하는 기법은?

- 송수신자 간 TCP 버퍼 크기 차이로 생기는 데이터 처리 속도 차이 해결 위해 송신자의 데이터 전송량을 조절하는 것.
- Stop And Wait과 Sliding Window 기법이 있다.

### Q2. 혼잡 제어는 무엇이고, 사용하는 기법은?

- 송신 측에서 보내는 데이터의 양이 라우터가 처리할 수 있는 양을 초과하여 초과된 데이터를 처리 못할 시 이를 손실 데이터로 판단하여 재전송을 반복하여 네트워크를 혼잡하게 만들게 된다. 이를 예방하기 위해 **송신 측의 전송 속도로를 적절히 조절하는 것**을 혼잡 제어라고 한다.
- AIMD, Slow Start, 빠른 재전송, 빠른 회복 등이 있다.

## E. 참고자료

🔗 https://evan-moon.github.io/2019/11/26/tcp-congestion-control/

🔗 https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html

🔗 https://code-lab1.tistory.com/30
