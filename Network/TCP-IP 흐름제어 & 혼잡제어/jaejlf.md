# 📍 흐름 제어 (Flow Control)

송/수신 측의 `데이터 처리 속도 차이`를 해결하기 위한 기법

- 보내는 쪽의 데이터 처리 속도가 받는 쪽의 처리 속도보다 빠르면 문제가 생길 수 있다.
- 수신 측에서 제한된 저장 용량을 초과한 이후에 도착하는 패킷은 손실될 수 있다.
- 패킷이 손실될 경우, 불필요한 추가 패킷 전송이 발생하게 된다.

<br>

## Stop and Wait

- 매번 전송한 패킷에 대해 `확인 응답(ACK)을 받은 후` 다음 패킷을 전송하는 방법
- 이러한 구조는 비효율적이라는 단점

<br>

## Sliding Window

- 수신 측에서 설정한 `윈도우 크기만큼`, 송신 측에서 `확인 응답 없이` 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 방법
- 수신 측의 윈도우 크기보다 작거나 같은 크기로 송신 윈도우를 지정하여 흐름 제어. 즉, 송신 측의 버퍼 범위는 수신 측의 여유 버퍼 공간을 반영하여 동적으로 변경
- Stop and Wait의 비효율성을 개선한 기법

<br>

💡 윈도우 = 송/수신 측에서 만들어진 버퍼의 크기, TCP 헤더의 Window Size 필드를 통해 윈도우 사이즈를 제어

<br><br>

# 📍 혼잡 제어 (Congestion Control)

네트워크의 혼잡을 피하기 위해, 송신 측에서 보내는 `데이터 전송 속도`를 제어하는 기법

- 송신 측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다.
- 만약 한 라우터에 데이터가 몰릴 경우 데이터를 모두 처리할 수 없게되고, 이 경우 송신 측에서는 데이터를 손실 데이터로 간주하여 재전송하게 되므로 네트워크는 더욱 더 혼잡하게 된다.
- 결국 오버플로우나 데이터 손실 문제가 발생할 수 있다.

<br>

## AIMD (Additive Increase Multicative Decrease)

- 합 증가, 곱 감소 알고리즘
- 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 `윈도우 크기를 1씩 증가`시켜가며 전송한다.
- 만약 전송에 실패하거나, TIME_OUT이 발생하면 `윈도우 크기를 절반으로 감소`시킨다.
- 네트워크 대역이 남는 상황에서도 윈도우 크기를 너무 조금씩 늘리기 때문에, 네트워크의 모든 대역을 활용하여 제대로 된 속도로 통신하기까지 시간이 오래 걸린다.
- 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이므로, 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다.
- 시간이 흐르면 평형 상태로 수렴하게 되기 때문에 공평한 방식이다.
  - 처음에는 나중에 진입한 쪽의 혼잡 윈도우 크기가 작기 때문에 불리하지만, 네트워크가 혼잡해지면 혼잡 상황을 해결하기 위해 먼저 진입해 혼잡 윈도우 크기가 큰 것들이 윈도우 크기를 줄이게 되기 때문에 이때에 남은 대역폭을 활용해 나중에 진입한 것들도 자신의 혼잡 윈도우 크기를 키울 수 있다.

<br>

## 느린 시작 (Slow Start)

- `윈도우 크기를 2배씩 증가` 시킨다.
- 혼잡이 감지되면 `윈도우 크기를 1로` 줄인다.
- 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만, 한 번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있다.
- 특정한 `임계점`을 정해놓고, 임계점에 도달하면 그 이후부터는 완만하기 `윈도우 크기를 1씩 증가`시킨다.
- AIMD 방식보다 더 효율적이지만, 혼잡한 상황이 된 경우에는 TIME_OUT이 될 때까지 기다리는 동안 큰 시간의 공백이 있다.

<br>

## 빠른 재전송 (Fast Retransmit)

- 세그먼트로 분할된 내용들이 순서대로 도착하지 않는 경우가 생길 수 있다. 먼저 도착해야할 패킷이 도착하지 않았을 경우에도 ACK 패킷을 계속해서 보낸다.
- 이런 상황이 발생했을 때, 순서대로 잘 도착한 마지막 패킷의 다음 순번을 ACK 패킷에 실어서 보낸다. 즉, 패킷이 손실되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 된다.
- 송신 측에서는 중복된 순번의 패킷을 3개 받으면, 데이터 손실로 감지하고 재전송한다.
- 송신 측은 자신이 설정한 TIME_OUT 시간이 지나지 않아도 바로 패킷을 재전송할 수 있기 때문에, 보다 빠른 전송률을 유지할 수있다.
- 송신 측에서 설정한 TIME_OUT까지 ACK 패킷을 받지 못하면, 혼잡을 감지하고 윈도우 크기를 절반으로 줄인다.

<br>

## 빠른 회복 (Fast Recovery)

- 혼잡 상태가 되면 `윈도우 크기를 절반으로 감소`시켜 선형 증가 시키는 방법
- 이 방법을 적용하면 혼잡 상황을 한 번 겪고 나서는 AIMD 방식으로 동작한다.

<br><br>

# 📍 TCP 혼잡 제어 정책

### TCP Tahoe

- 처음에는 `Slow Start`를 사용하다가 임계점에 도달하면 `AIMD`방식을 사용한다.
- `3 ACK Duplicated` 또는 `TIME_OUT`이 발생하면 임계점은 혼잡이 발생한 윈도우 크기의 절반으로, 윈도우 크기는 1로 줄인다.
- 혼잡 이후 Slow Strat 구간에서 윈도우 크기를 키울 때 시간이 너무 오래 걸린다는 단점이 있다.

<br>

### TCP Reno

- TCP Tahoe 방식과 마찬가지로 처음에는 `Slow Start`를 사용하다가 임계점에 도달하면 `AIMD`방식을 사용한다.
- TCP Tahoe와의 차이점은 `3 ACK Duplicated`와 `TIME_OUT`을 구분한다는 점이다. 
   - `3 ACK Duplicated`가 발생하면 `빠른 회복` 방식을 사용한다. 즉, 임계점은 줄어든 윈도우 값으로, 윈도우 크기는 절반으로 줄인다.
   - `TIME_OUT`이 발생하면 윈도우 크기를 1로 줄이고, 임계점은 변경하지 않는다.
