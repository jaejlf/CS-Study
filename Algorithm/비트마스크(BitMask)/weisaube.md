# 비트마스크 (BitMask)

## 📌 A. 비트마스크 정의

> 이진수를 사용하는 컴퓨터의 연산 방식을 이용하여, 정수의 이진수 표현을 자료 구조로 쓰는 기법

하나의 비트(bit)가 표현할 수 있는 경우는 두 가지

- 0: 꺼져 있다
- 1: 켜져 있다

<br/>

### 비트마스크의 장점

- 수행 시간이 빠르다
  - bit 연산이기 때문에 `O(1)`에 구현되는 것이 많음
- 코드가 짧다
  - 다양한 집합 연산자들을 비트연산자 한 줄로 표현 가능
- 메모리 사용량이 더 적다
  - 2^10가지의 경우를 10bit 이진수 하나로 표현이 가능
  - 하나의 정수로 매우 많은 경우의 수를 표현할 수 있기 때문에 메모리 측면에서 효율적
  - 더 많은 데이터를 미리 계산하여 저장할 수 있다(DP에 유용)

<br/>

### 비트 연산자

비트마스크를 이용하기 위해서 정수 변수를 비트 별로 조작할 수 있는 비트연산자를 사용한다.

<br/>

1. AND 연산: a,b 두 개의 비트가 **모두 켜져 있는** 상태에서만 비트를 켠다
   (ex. c = a & b)
2. OR 연산: a, b 두 개의 비트가 **하나라도 켜져 있는 경우**에 c의 비트를 켠다 (ex. c = a | b)
3. XOR 연산 : 비트가 **둘 중 하나만 켜져 있는 경우**에 c의 해당 비트를 켠다 (ex. c = a ^ b)
4. NOT 연산 : 정수 하나를 입력받아서 **켜져 있는 비트는 끄고, 꺼져 있는 비트는 켠 결과**를 반환한다 (ex. c = ~a)
5. 시프트(Shift) 연산: 정수 a의 비트들을 **왼쪽 또는 오른쪽**으로 원하는 만큼 움직인다. 사용하는 연산자 기호는 `<<` `>>`가 있다.

<br/>

## 📌 B. 집합 표현하기

<br/>

int형 정수(32bit)로 집합의 원소를 표현하면 다음과 같다.

```Swift
00000000...0000010011010 // {1,3,4,8} 집합을 표현한 것
```

즉, 1, 3, 4, 8 번째 비트가 1인 것을 { 1, 3, 4, 8 } 집합으로 나타낸 것이다.
<br/>

### 비트 연산자를 활용하여 부분 집합 만들기

<br/>

n이 어떤 집합의 원소 갯수라고 하면, 특정 부분집합에 대한 특정 원소의 포함여부는 각 원소마다 2가지 경우를 가진다.(들어간다/들어가지 않는다)

즉, 어떤 집합의 부분집합은 2의 n승 만큼 존재한다고 할 수 있다.

👉 이를 활용하여 특정 집합의 부분집합들을 찾을 수 있다.

예를 들어 배열 arr이 6개의 원소를 가진다면,

- 000000~111111의 숫자로 대변할 수 있는 부분집합들을 가질 것이다. (2의 n승개)

```Swift
arr = [3,6,7,1,5,4]
n = len(arr)

// 000000 ~ 111111의 경우 모두 확인
for i in range(1<<n):
// 원소는 n개(6개)만큼 존재하므로, 각 인덱스마다 해당 원소가 이번 부분집합에 들어갈지 말지를 확인
    for j in range(n):
        if i & (1<<j):
            print(arr[j], end='')
    print()
```

- `if i & (1<<j)`:

  - 핵심이 되는 확인 조건문이다.
  - 처음 반복문을 돌렸던 000000~111111의 수가 활용된다.
  - 1이 j번 왼쪽으로 시프트되면서 1~100000 따위의 형태를 띄고, i값인 000000~111111의 숫자와 비교된다.
  - 이 연산이 if문을 통과하려면 i값의 오른쪽부터 n번째 비트값이 1이어야만 한다. (1<<j는 최상위 자리를 제외하고는 모두 0이기 때문이다.)
  - 따라서 해당 자리에 넣을지 말지에 대한 경우의 연산이 처리된다.

<br/>

## 📌 C. 참고 자료

🔗 [비트마스크 (BitMask) 알고리즘](https://rebro.kr/63)

🔗 [[알고리즘] 비트연산자를 활용하여 부분집합 만들기](https://inuplace.tistory.com/224)
