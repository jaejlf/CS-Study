# 💡 트랜잭션(Transaction)

## 1. 개념

트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위, <br/>
또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.

하나의 트랜잭션은 `Commit` 되거나 `Rollback` 된다.

<br/>

## 2. 트랜잭션의 성질 (ACID)

### 1) Atomicity(원자성)

- 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.
- 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

### 2) Consistency(일관성)

-  트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
-  시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.

### 3) Isolation(독립성,격리성)

-  둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없다.
-  수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.

### 4) Durablility(영속성,지속성)

- 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

<br/>

## 3. Commit과 Rollback

### Commit

- 하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태일 때 이를 알려주기 위해 사용하는 연산이다.

### Rollback

- Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산이다.
- Rollback 시에는 해당 트랜잭션을 재시작하거나 폐기한다.

<br/>

## 4. 트랜잭션의 상태

![image](https://user-images.githubusercontent.com/75151848/192079556-6b09eb4f-e9a3-4567-ba47-f37bb49ea15b.png)

트랜잭션은 논리적으로 5가지의 상태에 있을 수 있다.

- Active : 트랜잭션이 현재 실행 중인 상태
- Failed : 트랜잭션이 실행되다 오류가 발생해서 중단된 상태
- Aborted : 트랜잭션이 비정상 종료되어 Rollback 이 수행된 상태
- Partially Committed : 트랜잭션의 연산이 마지막까지 실행되고 Commit이 되기 직전 상태
- Committed : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

<br/>

## 5. 트랜잭션의 관리를 위한 DBMS의 전략

### DBMS 구조 

![image](https://user-images.githubusercontent.com/75151848/192078922-11d50449-3806-489c-8816-ab3cf46bc247.png)

- 구성 요소 : 상부 `질의 처리기(Query Processor)` +  하부 `저장 시스템(Storage System)`
- 저장 단위 : 고정 길이의 page
- 저장 공간 : 비휘발성 저장 장치인 disk에 저장, 일부분을 Main Memory에 유지
- `페이지 버퍼 관리자` : 메인 메모리에 유지하는 페이지들을 관리하는 모듈. <br/>
  버퍼 관리 정책은 트랜잭션 관리에 중요한 결정을 가져온다. <br/>
  버퍼 관리 정책에 따라 트랜잭션의 UNDO 복구와 REDO 복구가 결정된다.
  
<br/>

  
### UNDO 복구

수정된 페이지들은 버퍼 관리자의 버퍼 교체 알고리즘에 따라서 디스크에 출력될 수 있다.

버퍼 교체는 전적으로 버퍼의 상태에 따라서 결정된다.

아직 완료되지 않은 트랜잭션이 수정한 페이지들도 디스크에 출력될 수 있으므로, 
만약 해당 트랜잭션이 어떤 이유든 정상적으로 종료될 수 없게 되면 트랜잭션이 변경한 페이지들은 원상 복구되어야 한다.

이러한 복구를 UNDO라고 한다.


#### 2가지 정책 (수정된 페이지를 디스크에 쓰는 시점)
- STEAL: 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책. (거의 모든 DBMS가 채택하는 버퍼 관리 정책) <br/>
  STEAL 정책은 수정된 페이지가 어떠한 시점에도 디스크에 써질 수 있기 때문에 필연적으로 UNDO 로깅과 복구를 수반한다.
  
- ¬STEAL: 수정된 페이지들을 최소한 트랜잭션 종료 시점(EOT, End of Transaction)까지는 버퍼에 유지하는 정책.


> #### 🤔 만약 버퍼 관리자가 트랜잭션 종료 전에는 어떤 경우에도 수정된 페이지들을 디스크에 쓰지 않는다면?
> 
> UNDO 오퍼레이션은 메모리 버퍼에 대해서만 이루어지면 되는 식으로 매우 간단해질 수 있다. <br/>
> 이 부분은 매력적이지만 이 정책은 매우 큰 크기의 메모리 버퍼가 필요하다는 문제점을 가지고 있다.

<br/>

### REDO 복구

REDO 복구란, UNDO 복구의 반대 개념으로 이미 커밋한 트랜잭션의 수정을 재반영하는 복구 작업을 말한다.

REDO 복구 역시 UNDO 복구와 마찬가지로 버퍼 관리 정책에 영향을 받는다.

#### 2가지 정책 (트랜잭션이 종료되는 시점에 해당 트랜잭션이 수정한 페이지들을 디스크에도 쓸 것인가 여부)

- FORCE: 수정했던 모든 페이지를 트랜잭션 커밋 시점에 디스크에 반영하는 정책. <br/>
  트랜잭션이 커밋되면 수정되었던 페이지들이 이미 디스크 상의 데이터베이스에 반영되었으므로 REDO 복구가 필요없다.
  물론, 데이터베이스 백업으로부터의 복구(미디어 복구) 시에는 REDO 복구가 요구된다.
  
- ¬FORCE: 수정했던 페이지를 트랜잭션 커밋 시점에 디스크에 반영하지 않는 정책. (거의 모든 DBMS가 채택하는 정책) <br/>
  커밋한 트랜잭션의 내용이 디스크 상의 데이터베이스 상에 반영되어 있지 않을 수 있기 때문에 반드시 REDO 복구가 필요하다.

<br/>

### 정리

DBMS는 버퍼 관리 정책으로 `STEAL` 과 `¬FORCE` 정책을 채택하고 있어, 이로 인해서 `UNDO 복구` 와 `REDO 복구` 가 모두 필요하게 된다.

UNDO 복구와 REDO 복구를 위해서 로그(log) 기법이 보편적으로 사용된다.

<br/><br/>

> ### 🔖 참고
> - https://coding-factory.tistory.com/226
> - https://wonit.tistory.com/462
> - https://d2.naver.com/helloworld/407507
