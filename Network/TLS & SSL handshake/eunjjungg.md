### 6. HTTPS의 구조
![image](https://user-images.githubusercontent.com/100047095/190899572-b9bd29f6-78a3-4eaa-beb5-dead70dad5e0.png)


1. 클라이언트가 Client Hello라는 메시지를 보내면서 SSL 통신을 시작함. 메시지에는 클라이언트가 제공하는 SSL 버전을 지정하고 암호 스위트로 불리는 리스트 등이 포함되어 있음.
2. 서버가 SSL 통신이 가능한 경우에는 Server Hello 메시지로 응답하고 클라이언트와 같이 SSL 버전과 암호 스위트를 포함함. 서버의 암호 스위트 내용은 클라이언트에서 받은 암호 스위트의 내용에서 선택된 것.
3. 서버가 Certificate 메시지를 송신함. 메시지에는 공개키 증명서가 포함되어 있음.
4. 서버가 Server Hello Done 메시지를 송신하여 최초의 SSL Negotiation이 끝났음을 알림.
5. SSL의 최초 Negotiation이 종료되면 클라이언트가 Client Key Exchange 메시지로 응답함. 메시지에는 통신을 암호화하는데 사용하는 Pre-Master Secret이 포함되어 있음.
6. 클라이언트는 Change Cipher Spce 메시지를 송신함. 이 메시지는 이 메시지 이후의 통신은 암호키를 사용해서 진행한다는 것을 나타내고 있음.
7. 클라이언트는 Finished 메시지를 송신함. 이 메시지는 접속 전체의 체크 값을 포함하고 있음. Negotiation이 성공했는지 여부는 서버가 이 메시지를 올바르게 복호화할 수 있는지 아닌지 결정됨.
8. 서버에서도 마찬가지로 Change Cipher Spce 메시지를 송신함.
9. 서버에서도 마찬가지로 Finished 메시지를 송신함.
10. 서버와 클라이언트의 Finished 메시지 교환이 완료되면 SSL에 의해서 접속이 확립됨. 통신은 SSL에 의해 보호되고 있고 여기부터는 애플리케이션 계층의 프로토콜인 HTTP를 통해 작업이 시작됨. HTTP 리스폰스를 송신하게 됨. 모든 통신이 완료되고 클라이언트가 접속을 끊고 close_notify 메시지를 송신함. 그 후에 TCP_FIN 메시지도 송신하여 TCP 접속도 종료하게 됨.

### 7. SSL, TLS

HTTPS에서는 SSL, TLS 프로토콜을 사용다만 SSL을 사용하면 처리가 느려진다는 점에서 HTTPS에도 문제점이 있다고 볼 수 있음 SSL 통신이 지연되는 이유는 두 가지가 있음

1. 통신 속도가 떨어지는 것
    1. 네트워크의 부하가 HTTP보다 2~100배 정도 느림, 근데 일어날 수밖에 없는게 SSL에 필요한 통신이 추가되기 때문에 전체적으로 처리해야 할 통신이 증가해버림
2. CPU나 메모리 등의 리소스를 다량으로 소비함으로써 처리가 느려짐
    1. SSL은 반드시 암호화 처리를 하고 있기 때문에 서버나 클라이언트에서는 암호화나 복호화를 위한 계산을 할 필요가 있음 → 서버나 클라이언트의 리소스를 소비하게 되어 리소스 부담이 커짐
