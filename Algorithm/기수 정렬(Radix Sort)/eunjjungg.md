# 1. 기수 정렬

> 계수 정렬, Counting Sort와 마찬가지로 비교 연산을 수행하지 않아 조건이 맞는 상황에서 빠른 정렬 속도를 보장함<br/> 
그러나 자릿수가 존재하지 않는 데이터를 기수 정렬로 정렬하는 것은 불가능함.
> 

![image](https://user-images.githubusercontent.com/100047095/193398496-01f0e884-fc73-42be-aa33-80b99acca07b.png)

출처 : [https://dudri63.github.io/2019/02/03/algo31/](https://dudri63.github.io/2019/02/03/algo31/)

**알고리즘 요약**

1. 현재 가지고 있는 데이터 중 가장 큰 자릿수가 100의 자리라고 함
2. 각 데이터들의 1의 자리를 비교해서 같은 데이터끼리 모음. 1의 자리가 작은 데이터들이 앞, 큰 데이터들이 뒤에 위치함
3. 같은 자릿수에 여러 데이터가 있을 경우 입력된 순서로 데이터를 모음
4. 10의 자리가 같은 데이터들끼리 오름차순으로 나열함.
5. 10보다 작은 숫자들은 배열에 위치했던 순서대로 맨앞에 위치하게 됨. (오름차순으로 위치하게 된다는 의미)
6. 100의 자리가 같은 데이터들끼리 오름차순으로 나열함.
7. 100보다 작은 숫자들은 배열의 제일 앞에부터 위치하게 됨

**특징**

1. 안정 알고리즘 : 중복된 숫자에 대해 앞서 있던 숫자가 정렬된 후에도 앞서 있음. 


<br/><br/>

# 2. 복잡도

- 시간 복잡도 : O(dN)
    - N은 데이터의 개수, d는 데이터들의 최대 자리수를 의미함. 기수 정렬은 비교연산을 수행하지 않고 버킷에 데이터들을 넣고 빼는 작업(N)을 최대 자릿수(d)만큼 수행함.
- 공간 복잡도 : 10진수의 경우 10개의 공간이지만 알파벳의 경우 26의 버킷이 필요하므로 정의하기 어려움.
