# 📍 저장 프로시저

- DB 내부에 저장된 일련의 SQL 명령문들을 하나의 함수처럼 실행하기 위한 쿼리의 집합
- DB에 대한 작업을 정리한 절차를 RDBMS에 저장한 쿼리의 집합
- 여러 쿼리를 하나의 함수로 묶은 것

<br>

## 일반 쿼리문 vs 저장 프로시저

### 일반 쿼리문 작동 방식

![image](https://user-images.githubusercontent.com/78673570/196021845-8bd5e30f-23d7-4572-9cbd-1ab3ca016836.png)

- 일반적으로 쿼리문 한 줄을 실행하더라도 위와 같이 많은 절차를 거친다.
- `최적화` 결과를 바탕으로 `컴파일 및 실행 계획 등록` 단계에서 해당 실행 계획 결과를 `메모리(캐시)`에 등록한다.

<br>

### 저장 프로시저 작동 방식

1. 저장 프로시저 정의

![image](https://user-images.githubusercontent.com/78673570/196022177-66e9911f-90e8-432d-a732-651166589218.png)

- 구분 분석 : 구문의 오류 파악
- 지연된 이름 확인 : 프로시저 실행 당시에 테이블 존재 여부를 확인 (저장 프로시저를 정하는 시점에서 해당 개체가 존재하지 않아도 상관없다 !)
- 생성 권한 확인 : 현재 사용자가 저장 프로시저를 생성할 권한이 있는지 확인
- 시스템 테이블 등록 : 저장 프로시저의 이름 및 코드가 시스템 테이블에 등록

<br>

2. 처음으로 저장 프로시저를 실행

![image](https://user-images.githubusercontent.com/78673570/196022453-544f2d62-9439-4787-8e4e-ac96a179b51b.png)

- 일반 쿼리문 작동 방식에서 `구문 분석` 단계 생략
- `저장 프로시저 정의` 단계에서 지연했던 개체 존재 유무를 `개체 이름 확인` 단계에서 수행

<br>

3. 이후의 저장 프로시저 실행

![image](https://user-images.githubusercontent.com/78673570/196022673-df2675b2-4504-45ee-8373-b9f3c0d8e9ef.png)

- 두 번째 실행부터는 메모리(캐시)에 있는 것을 그대로 가져와서 재사용한다.
- 이에 따라 수행 시간이 단축된다.

<br><br>

## 저장 프로시저의 장/단점

### 장점
- SQL Server의 성능을 향상시킬 수 있다.
  - 저장프로시저의 두번째 실행부터는 캐시(메모리)에 있는 것을 가져와서 사용하므로 속도가 빨라진다.
  - 여러개의 쿼리를 한번에 실행할 수 있다.
- 유지보수 및 재활용 측면에서 좋다.
  - 직접 SQL문을 호출하지 않고 저장 프로시저의 이름을 호출하도록 설정하여 사용하는 경우가 많은데, 이때 개발자는 수정요건이 발생할때 코드 내 SQL문을 건드리지 않아도 되기 때문에 유지보수 측면에서 유리해진다.
  - 한번 저장 프로시저를 생성해 놓으면, 언제든 실행이 가능하기 때문에 재활용 측면에서 매우 좋다.
- 보안을 강화할 수 있다.
  - 저장 프로시저는 사용자들에게 데이타에 대한 제한적인 접근을 허용케하는 전통적인 수단이다. 사용자별로 테이블에 권한을 주는게 아닌 저장 프로시저에만 접근 권한을 줌으로써 테이블의 모든 정보를 사용자에게 노출하지 않고 프로시저에서 선택한 정보만 사용자에게 보여줄 수 있다.
- 네트워크의 부하(전송량)를 줄일 수 있다.
  - 클라이언트에서 서버로 쿼리의 모든 텍스트가 전송될 경우 네트워크에는 큰 부하가 발생하게 된다. 하지만 저장 프로시저를 이용한다면 저장 프로시저의 이름, 매개변수 등 몇글자만 전송하면 되기 때문에 부하를 크게 줄일 수 있다.
  - 저장 프로시저를 사용하면, 서버 내부에서 이동하는 모든 데이타를 임시 테이블 혹은 변수에 저장할 수 있게 된다.

<br>

### 단점
- DB 확장이 어렵다.
  - 서비스 사용자가 많아져 서버의 수를 늘려야할 때, DB의 수를 늘리는 것이 더 어렵다. 
  - DB 교체는 거의 불가능
- 데이터 분석이 어렵다.
  - 개발된 프로시저가 여러 곳에서 사용 될 경우 수정했을 때 영향의 분석이 어렵다.
  - 배포, 버전 관리 등에 대한 이력 관리가 힘들다.
  - APP에서 SP를 호출하여 사용하는 경우 문제가 생겨도 해당 이슈에 대한 추적이 힘들다.
- 낮은 처리 성능
  - 문자, 숫자열 연산에 SP를 사용하면 오히려 c, java보다 느린 성능을 보일 수 있다.
