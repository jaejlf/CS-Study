# 📍 데이터베이스 정규화

관계형 데이터베이스의 설계에서 `중복을 최소화`하게 데이터를 구조화하는 프로세스

- 기본 정규형 : 제 1 정규형, 제 2 정규형, 제 3 정규형, BCNF
- 고급 정규형 : 제 4 정규형, 제 5 정규형
- 목적
  1. 중복을 배제하여 삽입/삭제/갱신 이상의 발생을 방지
  2. 각 릴레이션에 중복된 종속성을 여러 개의 릴레이션에 분할
  3. 어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 함
  4. 데이터 삽입 시 릴레이션을 재구성할 필요성 감소
  5. 효과적인 검색 알고리즘 생성 가능

<br>

## 1NF (제 1 정규형)

- 릴레이션에 속한 모든 속성의 도메인이 `더이상 분해되지 않는 원자값으로만 구성`된 정규형
- 각 로우마다 컬럼의 값이 1개씩만 존재해야한다 => 컬럼이 원자값을 가져야한다.

<br>

### 제 1 정규화 이전

![image](https://user-images.githubusercontent.com/78673570/185752390-cffeacb3-445d-479e-aa9c-fbee06cb9114.png)

- subject 컬럼의 속성이 원자값이 아니었다.
- 갱신/삭제 이상이 발생할 수 있다. (ex. Adam이 Biology 과목 수강 취소 → Maths 과목까지 수강 취소된다.)

<br>

### 제 1 정규화 이후

![image](https://user-images.githubusercontent.com/78673570/185752344-8ba58f94-2418-46a5-a84b-c2bd65e72e94.png)

- 모든 컬럼이 원자값을 가진다.
- 데이터의 중복은 더 증가했다. (데이터의 논리적 구성을 위해 이 부분은 희생)

<br>

## 2NF (제 2 정규형)

- 테이블의 모든 컬럼이 `완전 함수 종속`을 만족하는 정규형
- 기본키 중에 특정 컬럼에만 종속된 컬럼(= 부분적 종속)이 없어야 한다.

    > - 완전 함수 종속 : 어떤 속성이 기본키에 대해 완전히 종속일 때
    > - 부분 함수 정속
    >   - 어떤 속성이 기본키가 아닌 다른 속성에 종속되었을 때
    >   - 기본키가 복합키일 경우, 기본키를 구성하는 속성 중 일부에게만 종속된 경우

<br>

### 제 2정규화 이전

![image](https://user-images.githubusercontent.com/78673570/185752840-07ccc143-9c34-4af6-9a4c-8ab316d9bebe.png)

- 기본키는 `(name, subject)`로, name과 subject가 모두 있어야 한 로우를 구분할 수 있다.
- 그런데 age의 경우 name에만 종속되어 있다. => 부분 함수 종속 !
- 삽입/갱신/삭제 이상이 발생할 수 있다. (ex. 수강신청을 할 때, 불필요한 나이 정보까지 계속해서 중복 적재)

<br>

### 제 2정규화 이후

![image](https://user-images.githubusercontent.com/78673570/185752964-0bb19d39-84a7-40e3-9786-d096e5ac4cca.png)

- 두 개의 테이블로 분리하여, 각각의 테이블의 모든 컬럼이 `완전 함수 종속`을 만족한다.
-  삽입/갱신/삭제 문제를 겪지 않을 수 있다. (그러나 더 복잡한 테이블의 경우 갱신 이상을 겪기도 하는데 이를 해결하기 위한 것이 3차 정규화)


<br>

## 3NF (제 3 정규형)

- 기본키를 제외한 속성들 간의 `이행적 함수 종속`이 없는 정규형
- 기본키 이외의 다른 컬럼이 그 외 다른 컬럼을 결정할 수 없다.

    > 이행적 함수 종속 : A → B이고, B → C일 때, A → C인 관계
