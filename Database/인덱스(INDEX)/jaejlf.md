# 📍 인덱스 (INDEX)

![image](https://user-images.githubusercontent.com/78673570/192090630-fb562b03-b135-456f-975d-8e95f6040e58.png)

- 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
- 테이블의 Column을 색인화하여 해당 테이블의 레코드를 Full scan 하지 않는다 → 검색 속도가 향상된다 !

=> 특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 `정렬`하여 별도의 메모리 공간에 `데이터의 물리적 주소`와 함께 저장

<br>

## 특징

### 장점

- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
- 전반적인 시스템의 부하를 줄일 수 있다.

<br>

### 단점

- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
- 인덱스를 관리하기 위해 추가 작업이 필요하다.
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다. → 인덱스를 남잘하는 것보다는 SQL문을 더 효율적으로 짜는 것이 좋다 !

<br>

## 인덱스 활용

### 사용하면 좋은 경우

- Where 절에서 자주 사용되는 컬럼 : Full Scan(= 레코드의 처음부터 끝까지 read) 시 데이터가 정렬되어 저장되어있기 때문에, Where 절에 맞는 데이터들을 빠르게 찾아낼 수 있다.
- 외래키가 사용되는 컬럼
- Join에 자주 사용되는 컬럼

<br>

### 인덱스 사용을 피해야 하는 경우

- Data 중복도가 높은 컬럼
- DML이 자주 일어나는 컬럼 : INSERT, DELETE, UPDATE로 인해 데이터가 추가되거나 바뀐다면 인덱스 테이블 내에 있는 값들을 다시 정렬해야한다.

<br>

## 인덱스 자료구조

### 해시 테이블

- 키(key)와 값(value) 쌍으로 이루어진 데이터 구조
- 해시 충돌이라는 변수가 존재하지만 평균적으로 O(1)의 매우 빠른 시간만에 원하는 데이터를 탐색할 수 있다.

<br>

=> 그러나 해시 테이블은 등호(=) 연산에 최적화되어있기 때문에, 실제로 데이터베이스의 인덱스로는 잘 사용되지 않는다! 데이터베이스에서는 부등호(<, >) 연산이 자주 사용되는데, 해시 테이블 내의 데이터들은 정렬되어 있지 않으므로 특정 기준보다 크거나 작은 값을 빠른 시간 내에 찾을 수가 없기 때문이다.

<br>

### B+ Tree
![image](https://user-images.githubusercontent.com/78673570/209467637-9325ba9b-d2c2-41fd-99f2-68f25ca808dc.png)

- leaf 노드에만 데이터를 저장하고, leaf 노드가 아닌 노드에서는 자식 포인터만 저장하는 자료 구조
