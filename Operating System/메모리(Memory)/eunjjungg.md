# 1. 메인 메모리

CPU가 직접 접근할 수 있는 기억 장치

프로세스가 실행되려면 프로그램이 메모리에 올라와야 함. 

CPU는 레지스터가 지시하는대로 메모리에 접근 → 다음에 수행할 명령어를 가져옴. 명령어 수행 시 메모리에 필요한 데이터가 없으면 해당 데이터를 먼저 가져와야 함. 이 역할 수행을 MMU가 함.

<br/><br/>

# 2. MMU

- 메모리 관리 장치
- 논리 주소 → 물리 주소 변환
- 메모리 보호, 캐시 관리 등 CPU가 메모리에 접근하는 것을 총 관리하는 하드웨어
- 메모리의 공간이 한정적이기에 가상 주소(프로그램 상에서 사용자가 보는 주소 공간)를 사용하는데 이 가상 주소를 실제 데이터가 담긴 주소로 변환해주는 것을 MMU가 담당
- 물리 주소로만 접근하지 않아도 되기에 프로세스의 크기가 실제 메모리의 용량을 초과해도 실행될 수 있게 해줌.

<br/>

**MMU의 메모리 보호**

프로세스는 독립적인 메모리 공간을 가져야 하고 자신의 공간만 접근해야 함 → 다른 프로세스의 메모리 접근이 오면 trap을 발생시켜야 함. 

따라서 base와 limit을 사용한 메모리 보호 기법이 존재. base register는 메모리상의 프로세스 시작 주소를 물리 주소로 저장하고 limit register는 프로세스 사이즈를 저장함. 프로세스의 접근 가능한 합법적인 메모리 영역(`x`)은 `base <= x < base+limit`가 됨. 넘어서서 요구하면 trap 발생. 안전성을 위해 base와 limit 레지스터는 커널 모드에서만 수정이 되도록 설계함.

<br/><br/>

# 3. 메모리 과할당

실제 메모리의 사이즈보다 더 큰 사이즈의 메모리를 프로세스에게 할당한 상황. 

이때 1. 프로세스 실행 도중 페이지 폴트가 발생하거나 2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾거나 3. 모든 메모리가 사용중이라 빈 프레임을 찾지 못해 페이지를 올리지 못하는 문제가 발생하게 됨. 이렇게 되면 사용자가 눈속임을 한 것을 인지하게 됨.

이를 해결 위해서는 빈 프레임 확보가 필요함. 확보를 위해서는 1. 메모리의 프로세스를 종료시켜 프레임을 얻거나 2. 프로세스 하나를 swap out하고 이를 빈 프레임으로 사용하는 방법을 채택함. 1번은 사용자에게 페이징 시스템을 들킬 가능성이 높아 지양해야 함. 

<br/><br/>

# 4. 페이지 교체

빈 프레임이 없는 상황에서 victim 프레임을 선정하여 프레임을 비울 때와 원하는 프레임으로 올려줄 때 → 총 두 번의 디스크 접근이 일어남. 그러나 페이지 교체가 많이 일어나면 디스크 IO가 많이 일어나 오버헤드가 발생할 수 있음. 따라서 오버헤드를 줄이는 방법도 고려 필요.

1. 변경 비트 활용
    1. 변경 비트를 모든 페이지마다 두어 victim 페이지가 정해지면 해당 페이지를 비트를 확인함. 
    2. 비트가 set이라면 해당 페이지 내용이 디스크 상과 달라짐. 따라서 디스크에 기록이 필요함. 
    3. 비트가 clear이라면 해당 페이지 내용은 디스크 상과 같음. 
2. 상황에 따른 알고리즘 선택
    1. FIFO, OPT, LRU 등의 페이지 교체 알고리즘을 적재 적소에 사용해야 함.

<br/><br/>

# 5. 캐시 메모리

주기억장치에 저장된 내용의 일부를 임시로 저장하는 기억장치로 CPU와 주기억장치의 속도 차이로 발생하는 병목현상을 방지하기 위한 방법

CPU가 이미 봤던 내용을 다시 접근할 때 메모리 참조 과정의 비용을 줄이기 위해 캐시를 사용함. 

<br/>

**캐시를 활용한 CPU와 기억 장치의 상호작용**

1. CPU에서 주소를 전달 
2. 캐시에 명령이 존재하는지 확인
    1. HIT : 존재 → 해당 명령어를 CPU로 전송하고 return 
    2. MISS : 존재 X → 명령어를 가지고 주기억장치로 접근 → 해당 명령어를 가진 데이터 인출 → 명령어 데이터를 캐시에 저장 → 명령어를 CPU로 전송 → return 

따라서 캐시의 적중률을 극대화하는 것이 비용을 획기적으로 줄일 수 있는 방법임. 적중률을 극대화하기 위해 사용하는 것이 **지역성의 원리**. 

<br/>

**캐싱 라인**

빈번하게 사용되는 데이터를 캐시에 저장했어도 내가 필요한 데이터를 찾을 때 모든 데이터를 순회하는 것은 낭비. 캐시에 목적 데이터가 있다면 바로 접근해서 출력 가능해야 캐시 활용이 유의미함. 따라서 캐시에 데이터를 저장할 때 자료구조를 활용해 데이터가 묶여서 저장됨. 이를 캐싱 라인이라고 함. 이를 활용하면 캐시에 저장하는 데이터에 데이터의 메모리 주소를 함께 저장하면서 빠르게 원하는 정보를 찾을 수 있음.
