# 1. Paging & Segmentation

> 가상 메모리를 관리하는 기법으로 사용하는 메모리 공간을 잘게 나눠 비연속적으로 실제 메모리에 할당하는 메모리 관리 기법
> 

<br/><br/>

# 2. Paging

프로세스의 주소 공간을 Page란 단위의 고정된 사이즈로 나누어 물리적 메모리에 불연속적으로 저장하는 방식. 페이징 방식으로 메모리를 할당하게 되면 실제 프로세스가 실행될 때는 각각의 페이지들이 실제 메모리의 어디에 위치하고 있는지 빠르게 알 수 있어야 함. 프로세스의 입장에서는 자신이 사용하는 메모리 공간이 흩어져있는 조각들이 아니라 하나의 연속된 메모리 공간으로 이해할 수 있어야지 효율적 실행이 가능함.

즉, 페이징은 프로세스가 바라보는 메모리 주소 공간(논리 주소)과 실제 메모리 공간(물리 주소)을 분리하여 효율적인 메모리 할당, 참조를 달성을 도움.

CPU는 논리 주소로 프로그램이 설정한대로 프로그램이 설정한대로 연속적인 주소값으로 명령을 내리고 → 메모리로 가기 전에 각 페이지의 실제 메모리 주소가 저장되어 있는 테이블에서 논리 주소가 물리 주소로 변경되어야 함.

<br/>

**용어**

![image](https://user-images.githubusercontent.com/100047095/194754969-f4153c86-6579-4cbd-b3c5-d4807f458d93.png)

- Frame : 페이지가 저장된 실제 메모리의 위치 영역의 단위
- Page : 프로세스가 바라보고 잇는 메모리 공간, 논리 주소 공간의 단위
- Page Table : 각 페이지가 실제 메모리의 어떤 프레임을 담당하는가에 대한 매핑 정보를 담고 있는 자료구조. 프로세스가 실행될 때 연속된 위치의 메모리라고 이해한 상태로 각각의 페이지가 어디에 있는지 빠르게 찾을 수 있도록 도와줌.
    - Page table은 프레임 번호를 담고 있는 배열
    - Page table의 index == 페이지 번호
    - Page table의 value == 프레임 번호

<br/>

**단점**

내부 단편화 문제 

- 페이징의 방식으로 외부 단편화 문제는 해결할 수 있지만 내부 단편화 문제는 해결할 수 없음. 내부 단편화 문제는 프로세스 크기가 페이지 크기의 배수가 아닐 경우 마지막 페이지는 한 페이지를 다 채울 수 없어서 발생하는 메모리의 낭비 문제임.
    - 페이지 크기가 작은 경우 내부 단편화 문제는 감소되지만 페이지 테이블의 크기가 증가하게 됨.

<br/><br/>

# 3. Segmentation

프로그램의 논리적인 내용 단위로 프로세스의 메모리 공간을 분리하는 기법. (페이징은 고정 크기로 메모리 공간을 분리했음.) 논리적인 내용 단위로 자르기 때문에 세그먼트들의 크기는 일반적으로 동일하지 않음. 세그먼트의 논리 주소는 세그먼트의 번호 + 오프셋으로 이루어짐. 

- 세그먼트 테이블 : 각각의 세그먼트가 차지하는 크기가 서로 다르기 때문에 세그먼트의 실제 메모리 위치 정보 + 끝 주소 정보를 포함함.

<br/>

**단점**

외부 단편화 문제

- 세그멘테이션 방식은 가변적인 크기를 가져가기 때문에 내부 단편화 문제는 해결하지만 외부 단편화 문제가 발생할 수 있음.
