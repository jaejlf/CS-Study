# 1. 인터럽트

> CPU가 프로그램을 실행하고 있을 때 입출력 하드웨어 장치 등의 예외 상황이 발생하여 처리가 필요할 경우에 잠시 프로그램을 중단하고 발생한 일을 처리한 후 다시 실행중인 작업으로 돌아오는 것 <br/>
외부 인터럽트와 내부 인터럽트로 구분 되어있는데 내부 인터럽트는 trap이라고 더 많이 불림 <br/>
> 

<br/>

### a. 외부 인터럽트

- 전원 이상 인터럽트, Power fail interrupt
정전이 발생하거나 파워에 이상이 발생했을 때 동작
- 기계 착오 인터럽트, Machine check interrupt
CPU에 문제가 발생할 때 동작
- 외부 신호 인터럽트, External interrupt
    - 타이머에 의한 인터럽트
    여러 프로세스가 하나의 CPU를 공유하기 때문에 다양한 방법으로 CPU는 어떤 프로세스를 다룰지 결정할 수 있다. 
    여기서 시분할 방식(time sharing)의 선점(Preemptive) 스케줄링을 선택한 경우 자원이 할당된 시간을 다 썼을 때 Context Switching이 발생하여 프로세스가 중단 됨.
    이를 타이머에 의한 인터럽트라고 함
    - 키보드로 인터럽트 키를 누른 경우
    - 외부장치로부터 인터럽트 요청이 있는 경우
- 입출력 인터럽트, I/O Interrupt
입출력 장치가 데이터 전송을 요구하거나 전송이 끝나 다음 동작이 수행되어야 하는 경우

<br/>

### b. 내부 인터럽트 trap

> 잘못된 명령이나 잘못된 데이터를 사용할 때 발생
> 
- 프로그램 검사 인터럽트, Program check interrupt
    - Division by zero
    - Overflow / Underflow
    - 기타 프로그램의 Exception

<br/><br/>

# 2. 인터럽트 동작 과정

1. 프로그램 실행 중단 
: 현재 실행중이던 명령어까지 수행
2. 현재의 프로그램 상태 보존 
: 인터럽트 처리 종료 후 복귀를 위해 PC (Program Counter) 의 값을 스택에 저장함
3. 인터럽트 처리 루틴 실행 : 인터럽트를 요청한 장비를 식별
4. 인터럽트 서비스 루틴 (ISR, Interrupt Service Routine) 실행 
: 인터럽트 원인을 파악하고 실질적인 작업을 수행
5. 상태 복구 
: 인터럽트 발생 시 저장해둔 PC(Program Counter)를 다시 복구함
6. 중단된 프로그램 실행 재개
: PC의 값을 이용하여 이전 수행 중이던 프로그램을 재개

<br/>

```jsx
좀 더 자세하게...
출처 : https://dar0m.tistory.com/257?category=976685

**Process A 실행 중 디스크에서 어떤 데이터를 읽어오라는 명령을 받았다고 가정**

1. Process A는 System Call을 통해 인터럽트를 발생시킴 

2. CPU는 현재 진행 중인 기계어 코드를 완료함

3. 현재까지 수행중이었던 상태(메모리 주소, 레지스터 값, 하드웨어 상태...)를 
해당 process의 PCB(Process Control Block)에 저장함

4. PC에 다음에 실행할 명령의 주소를 저장

5. 인터럽트 벡터를 읽고 ISR(Interrupt Service Routine)의 주소값을 얻어 ISR로 점프하여 루틴 실행

6. 해당 코드를 실행

7. 일을 다 처리하면 대피시킨 레지스터를 복원함

8. ISR의 끝의 IRET 명령어에 의해 인터럽트가 해제 됨
(IRET : 인텔의 명령어로 인터럽트의 모든 처리를 완료하고 다시 테스크로 복구하는 명령어임)

9. 대피시킨 PC 값을 복원하여 이전 실행 위치로 복원함 
```

<br/><br/>

# 3. Polling vs Interrupt

![image](https://user-images.githubusercontent.com/100047095/183128593-7d848091-24d1-4c12-8a29-1c3640b44230.png)

출처 : [https://dar0m.tistory.com/257?category=976685](https://dar0m.tistory.com/257?category=976685)

<br/>

### a. Polling ?

프로세스 1이 실행 중에 Disk로부터 I/O 요청이 발생하면 운영체제는 I/O 요청이 완료될 때까지 반복적으로 폴링함. 

디스크가 I/O 요청의 처리를 완료하면 프로세스 1이 다시 동작함

<br/>

### b. Interrupt ?

프로세스 1이 실행 중에 있다가 Disk로부터 I/O 요청을 받으면 요청을 처리하는 동안에 운영체제는 프로세스 2를 CPU에서 실행시키게 됨. 

프로세스 1에 대한 디스크 요청이 완료되면 인터럽트를 발생시켜 운영체제는 프로세스 1을 다시 CPU에서 실행시킴.

따라서 Interrupt를 사용하면 CPU 연산과 I/O 장치 작업을 중첩시켜 수행할 수 있음. 그렇기 때문에 폴링보다 CPU 사용률적인 부분에서는 좋음! 

<br/>

### c. Interrupt가 무조건 Polling 보다 좋은 것은 아님!

예를 들어 단 한 번의 폴링으로만 끝날 정도의 빠른 하드웨어 장치라면 인터럽트보다 폴링이 더 효율적임. 

왜냐하면 인터럽트를 사용하게 되면 프로세스를 다른 프로세스로 Context Switching이 발생하게 되고 이때 많은 자원들이 소모되므로 많은 비용이 수반됨 

그렇기에 빠른 하드웨어 장치라면 폴링이 효율적이고 느린 하드웨어 장치라면 인터럽트가 효율적임

<br/>

### d. 우선순위 판별방법

- 폴링 방식
    
    사용자가 명령어를 사용해 입력 핀의 값을 계속 읽어 변화를 알아내는 방식
    
- 인터럽트 방식
    
    MCU(컴퓨터) 자체가 하드웨어적으로 변화를 체크하여 변화 시에만 일정한 동작을 하는 방식
    

✅ 실시간 대응이 필요한 발생시기를 예측하기 힘든 경우에 인터럽트는 컨트롤러가 가장 빠르게 대응할 수 있는 방식임
