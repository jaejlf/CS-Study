# 💡 교착 상태 (DeadLock)

## 1. 정의

![](https://velog.velcdn.com/images/wisdom-one/post/20deffd0-973c-4287-9533-194ee4367fbe/image.png)


`교착 상태(DeadLock)` 란, **둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상** 을 말한다.

<br/>

## 2. 발생 조건

교착 상태는 다음의 4가지 조건을 모두 만족하여야만 발생한다. 즉, 하나라도 성립하지 않으면 교착 상태가 발생하지 않는다.

### 1) 상호 배제 (Mutual exclusion)
자원은 한 번에 한 프로세스만 사용할 수 있다. 이미 다른 프로세스가 자원을 사용 중이라면, 요청한 자원이 해제될 때까지 기다려야 한다.

### 2) 점유 대기 (Hold and wait)
최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당된 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.

### 3) 비선점 (No preemption)
다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없다.


### 4) 순환 대기 (Circular wait)
자원을 사용하기 위해 대기하는 프로세스들이 순환 형태로 대기하고 있어야 한다.

<br/>

## 3. 해결 방법

교착 상태를 해결하기 위한 방법은 크게 3가지가 있다.
- 교착 상태가 발생할 수 있는 가능성을 차단하기 (예방 기법)
- 교착 상태를 회피하기
- 교착 상태를 탐지하여 회복하기



### 1) 예방 기법 (Prevention)

교착 상태의 발생 조건 4가지 중 하나라도 만족하지 않으면, 교착 상태는 발생하지 않는다. 예방 기법은 이것을 이용해 발생 조건 중 하나를 제거하여 교착 상태의 발생 자체를 막도록 한 방법이다.

예방 기법은 심각한 `자원 낭비`와 특정 프로세스의 `무한 대기` 가능성이 있다.

- `상호 배제` 방지 : 한 번에 여러 프로세스가 공유 자원을 사용할 수 있도록 한다. 단 **동기화** 문제가 발생할 수 있다.
- `점유 대기` 방지 : 프로세스가 실행되기 전 필요한 모든 자원을 할당(total allocation)하여, 나중에 또다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 한다. 하지만 이 방법은 심각한 **자원 낭비**와 **무한 대기** 현상을 초래할 수 있다.
- `비선점` 방지 : 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 가진 자원 반납하고 요구한 자원을 사용하기 위해 기다리도록 한다. 이 방법 역시 **자원 낭비**와 **무한 대기**를 초래할 수 있다.
- `순환 대기` 방지 : 자원에 고유번호를 할당한 후 순서대로 자원을 요청하도록 한다. 이 방법은 순서를 지켜야 하기 때문에 당장 필요없는 자원을 먼저 할당받아야 하고, 실제로 필요한 자원을 확보하기 위해 지금 당장 필요 없는 순서상의 하위 자원들을 확보하느라 많은 시간을 보내야 한다는 문제가 있다. 이 방법 역시 **자원 낭비**와 프로세스의 **무한 대기** 현상이 발생할 수 있다.

### 2) 회피 기법 (Avoidance)

회피 기법은 교착 상태를 피하기 위해, 시스템의 상태가 `안전 상태 (safe state)` 로만 가도록 지속적으로 제어하는 기법이다. 예방 기법보다는 덜하지만, 여전히 자원 낭비가 발생한다.

#### 안전 상태 (safe state) 
- `안전 상태` 란, 모든 프로세스가 유한 시간 내에 정상적으로 종료될 수 있는 상태로, 교착 상태가 발생할 수 없는 상태다. 
- 반대로 그렇지 못한 상태는 `불안전(unsafe) 상태` 라고 하며, 교착 상태로 갈 가능성이 있는 상태이다.

#### 은행원 알고리즘 (Banker's Algoithm, Dijkstra)
- 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래되었다.
- 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피하는 알고리즘이다.
- 안전 상태면 자원을 할당하고, 아니면 다른 프로세스들이 자원을 해지할 때까지 대기한다.



### 3) 탐지 기법 (Detection)

교착 상태의 발생을 허용하고, 발생 시 이를 탐지하는 기법이다.
자원 할당 그래프(Resource Allocation Graph, RAG) 또는 은행원 알고리즘과 비슷한 알고리즘으로 교착 상태를 탐지할 수 있다.

#### 자원 할당 그래프

- 프로세스와 자원을 노드로 하는 방향성 이분 그래프
- 프로세스 &rarr; 자원 : 대기
- 프로세스 &larr; 자원 : 할당
- `싱크` : 자원으로 향하는 엣지가 없는 프로세스

![](https://velog.velcdn.com/images/wisdom-one/post/238543e2-9741-4c96-8eb6-fa1d01750dfa/image.png)

`그래프 제거법` 
- 싱크로 들어오는 방향의 모든 엣지를 제거하는 작업을 반복하여 엣지가 모두 제거되면 교착 상태가 없다고 판단한다.
- 지워지지 않는 엣지가 있다면 그 엣지에 연결되어 있는 프로세스들이 교착 상태에 빠져있다고 판단한다.

<br/>


#### 탐지 알고리즘

- P : 프로세스의 개수
- R : 자원의 개수
- Available : 할당 가능한 자원의 개수. (길이 R)
- Allocation : 현재 각 프로세스에 할당된 자원의 개수. (P*R 배열)
- Request : 현재 각 프로세스가 요청하고 있는 자원의 개수. (P*R 배열)


1. 초기화
_`Work = Available`_ 
_`Allocation[i] != 0 이면, Finish[i] = false`
`그렇지 않으면 Finish[i] = true`_

2. 자원 할당 가능한지 검사
_`Finish[i] == false && Request[i] <= Work`_  를 만족하는 i가 있는지 검사.
없다면 step 4로 이동.

3. 할당된 자원 해제 및 Finish
_`Work = Work + Allocation[i]`_
_`Finish[i] = true`_
step 2로 이동

4. Finish 되지 못한 프로세스가 있는지 검사 
_`Finish[i] == false`_ 를 만족하는 i가 존재한다면, 시스템이 교착 상태에 있다고 판단한다. 또한  i 프로세스는 Deadlock에 빠져있는 프로세스이다. 

<br/>

### 4) 회복 기법 (Recovery)

교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 기법이다.

#### 프로세스 종료 (Process Termination) 방법
- 교착 상태를 형성한 프로세스들 중 몇 개를 강제로 종료시켜 이들로부터 반남된 자원으로 복구하는 방법
- 종료 비용(강제 종료되는 프로세스가 읽게 되는 일의 양)이 최소인 프로세스부터 종료시켜 나가는 방법과 교착 상태에 있는 모든 프로세스를 종료하는 방법이 있다.

#### 자원 선점 방법
- 프로세스에 할당된 자원을 선점하여, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에게 할당해주는 방법.
- 종료 비용이 작은 프로세스 위주로 자원을 선점한다.

<br/><br/>

## 🔖 참고
- [[운영체제] 데드락(Deadlock, 교착 상태)이란?](https://chanhuiseok.github.io/posts/cs-2/)
- [교착 상태 탐지](https://velog.io/@lcy960729/%EA%B5%90%EC%B0%A9-%EC%83%81%ED%83%9C-%ED%83%90%EC%A7%80)

