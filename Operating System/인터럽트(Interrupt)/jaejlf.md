# 📍 폴링 (Polling)

- CPU가 일정한 시간 간격을 두고 각 자원들의 상태를 주기적으로 확인하는 방식
- 폴링의 간격을 적절히 정해야한다.
- 각 자원들은 직전 폴링 이후 변화된 자신의 상태를 다음번 폴링 때까지는 알릴 수 없다.
- 아무 일이 일어나지 않아도 CPU는 폴링에 일정량의 시간을 들여야한다.


<br><br>

# 📍 인터럽트 (Interrupt)

= 끼어들다, 중단시키다

- 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우, 현재 실행 중인 작업을 중단하고 발생한 상황을 처리한 후 다시 실행 중인 작업으로 복귀하는 것
- 각 자원들이 능동적으로 자신의 상태변화를 CPU에게 알리는 방식
- CPU는 따로 시간을 들이지 않아도 된다.
- 자원들은 상황이 발생하면 즉시 알려 처리 받을 수 있다.
- 오늘날 대부분의 시스템에서 채택하고 있다.

<br>

## 인터럽트의 종류

### 외부 인터럽트

> CPU 코어 외부에서 어떤 일이 발생한 것을 전기적인 신호로 CPU에게 통지하는 경우

- 정전/전원이상 인터럽트 : 정전 또는 전원공급의 이상으로 인한 인터럽트
- 기계고장 인터럽트 : CPU 및 기타 하드웨어의 오류로 인한 인터럽트
- 외부 인터럽트
  - 자원이 할당된 시간이 다 끝난 경우
  - 키보드로 인터럽트 키를 누른 경우(ex. Ctrl + Alt + Del)
  - 외부 장치로부터 인터럽트 요청이 있는 경우
- 입출력 인터럽트
  - 입출력 장치가 데이터 전송을 요구하거나 전송이 끝나 다음 동작이 수행되어야할 경우
  - 입출력 데이터에 이상이 있는 경우

<br>

### 내부 인터럽트

> 잘못된 명령이나 잘못된 데이터를 사용하여 CPU 내부에서 실행하면서 인터럽트에 걸리는 경우  
> CPU 스스로 자신에게 인터럽트를 해야하는 경우이며, `트랩(Trap)` 이라고도 한다.

- 프로그램 검사 인터럽트
  - 0으로 나누는 경우
  - Overflow & Underflow
  - 기타 프로그램 Exception

<br>

### 소프트웨어 인터럽트

> 사용자가 프로그램을 실행시키거나 OS를 호출하는 동작을 수행하는 경우

- 대표적인 형태는 프로그램에서 감시 프로그램(SVC) 호출
- SVC(SuperVisor Call)
  - 사용자가 프로그램을 실행시키거나 감시 프로그램(Supervisor)을 호출하는 동작을 수행하는 경우
  - 복잡한 입출력 처리를 하는 경우

<br>

## 인터럽트 처리 과정

![image](https://user-images.githubusercontent.com/78673570/183284269-18e26fe0-3c21-471d-854f-fc1d64cb0ee3.png)

- PC = Program Counter, 다음에 실행될 명령어의 주소를 갖고 있는 프로그램 카운터  
-  PSW = Program Status Word, 시스템 내부의 순간순간의 상태를 기록하고 있는 정보
- 제어 스택(Control Stack), 인터럽트 처리 루틴(Interrupt Service Routine), 사용자 프로그램(User's Program)은 `커널`에 위치

장치가 CPU에게 인터럽트 신호 전송 → CPU는 실행 중인 명령어를 완료시키고 인터럽트 신호를 확인 → 현재 수행 중인 프로그램 정보 저장 → 인터럽트 처리 루틴 실행 → PC, PSW 값 원래대로 재저장 → 인터럽트 걸린 다음 명령어부터 실행 재개

---

\# 인터럽트 신호 확인 \#

\# 현재 수행 중인 프로그램 정보 저장 \#

0️⃣ 프로세스 내의 값들은 인터럽트 직전의 상황이다.

1️⃣ PC 값을 제어 스택에 저장한다.

2️⃣ 레지스터 값들을 제어 스택에 저장한다.

3️⃣ 스택 포인터의 값을 T-M으로 변경한다. (저장된만큼)

4️⃣ PC에 인터럽트 처리 루틴의 시작 주소인 Y를 넣어준다.

\# 인터럽트 실행 \#

\# 인터럽트 실행 종료 \#

\# 사용자 프로그램이 다시 실행될 수 있는 환경 만들기 \#

5️⃣ 스택 포인터의 값(T-M)으로 레지스터 값들을 복원한다.

6️⃣ 스택 포인터의 값을 T로 변경한다.

7️⃣ PC에 제어 스택에 저장해두었던 기존 PC값을 넣어준다.

\# 인터럽트 걸린 다음 명령어부터 실행 재개 \#

<br>

💡 문맥교환 (Context Switching)

 - 문맥 = 프로세스의 상태 정보
 - 문맥교환 = 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해 이전의 프로세스의 상태를 PCB에 보관하고 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정

<br>


## 다중 인터럽트의 처리

![image](https://user-images.githubusercontent.com/78673570/183287215-6e505637-de23-4d2e-a9c3-c32d70df1cf3.png)

- 순차처리 : 인터럽트를 처리하는 동안 발생한 인터럽트는, 현재 처리가 끝난 후 처리하는 방식
- 중첩처리 : 현재 처리 중인 인터럽트를 잠시 접어두고 또 다른 인터럽트로 실행을 옮길 수 있도록 하는 방식

인터럽트의 중요도에 따라서 우선순위가 더 높은 경우에는 중첩을, 그렇지 않은 경우에는 순차적으로 구현하는 것도 방법이다.
