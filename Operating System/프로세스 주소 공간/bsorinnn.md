# 프로세스 주소 공간

<img src="https://static.javatpoint.com/difference/images/process-vs-thread2.png">

<br>

프로세스 주소 공간은 코드, 데이터, 스택, 힙으로 이루어져 있다.

- 코드 Segment: 프로그램 소스 코드 저장
- 데이터 Segment: 전역 변수 저장
- 스택 Segment: 함수, 지역 변수 저장
- 힙 Segment: 참조형 데이터 저장

#### 코드(Code) Segment

- 프로그래머가 작성한 **소스 코드**가 들어 가는 부분. 즉, 실행할 프로그램의 코드가 저장되는 영역으로 **텍스트 영역**이라고 하기도 한다.
- 실행 파일을 구성하는 명령어들이 올라가는 메모리 영역으로 **함수, 제어문, 상수 등 함수에 대한 기계어 코드**가 여기 지정된다.
- 컴파일 시 결정되고 중간에 코드를 바꿀 수 없도록 **Read-Only**로 지정되어 있다.

<br>

#### 데이터(Data) Segment

- 프로그램의 **초기값이 있는 전역 변수, 배열, 정적(static) 변수**가 저장되는 영역<br>
  → 프로그램이 구동되는 동안 **항상 접근 가능한 변수** 가 저장되는 영역
- 전역 변수, static 값을 참조한 코드는 컴파일 후에는 Data 영역의 주소값을 가리킨다.
- 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.
- 실행 도중 전역 변수가 변경될 수 있으므로 **Read-Write**로 지정되어 있다.

<br>

#### 스택(Stack) Segment

- 함수의 호출과 관계되는 **지역변수와 매개변수**가 지정되는 영역
- 함수의 호출과 함께 할당되며, **함수의 호출이 완료되면 소멸**
- 원시타입의 데이터가 값과 함께 할당된다
- Heap 영역에 생성된 Object 타입의 데이터 참조값이 할당된다
- LIFO 특성을 가진다
- 메모리의 높은 주소에서 낮은 주소 방향으로 할당된다.
  - 프로그램이 실행되면 메모리를 얼마나 사용할 지 미리 계산할 수 없으므로 stack 의 뒷부분에서부터 주소 매겨짐
- **컴파일 시 크기가 결정되기 때문에 무한히 할당 불가**. 따라서 재귀함수가 너무 깊게 호출되거나 함수가 지역 변수를 너무 많이 가지고 있어 stack 영역 초과 시 stack overflow 에러 발생

<br>

#### 힙(Heap) Segment

- **런타임에 크기가 결정되는 메모리 영역**
- 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됨
- 참조형의 데이터 값이 저장된다
  - ex) 클래스, 클로저
- 힙은 메모리의 낮은 주소에서 높은 주소 방향으로 할당된다
- Heap과 Stack은 같은 공간을 공유한다
  - Heap이 메모리 위쪽 주소부터 할당, Stack이 메모리 아래쪽 주소부터 할당
  - 각 영역이 상대 공간을 침범하면 Heap Overflow, Stack Overflow

### 정리

- Code, Data는 Complie time에 데이터 결정, 이후 변동 ❌
- Stack Heap은 Runtime 시 메모리 사용 결정

### Q. 이렇게 구역을 나눈 이유는?

<br>

**최대한 데이터를 공유하여 메모리 사용량을 줄이기 위해서**

Code는 같은 프로그램 내에서는 모두 같은 내용이기 때문에 따로 관리.

Stack과 Data를 분리한 이유는 스택 구조의 특성과 전역 변수의 활용성 위해

```
프로그램의 함수와 지역 변수는 LIFO 특성을 가진 스택에서 실행됨.
따라서 이 함수들 안에서 공통으로 사용하는 '전역 변수'는 따로 지정해주면 메모리 세이브 가능!
```

## 참고자료

🔗 https://dar0m.tistory.com/258

🔗 https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Process%20Address%20Space.md
