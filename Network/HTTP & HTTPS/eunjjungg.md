### 0. 개요

HTTP도 클라이언트 ↔︎ 서버 통신을 함 이때의 클라이언트는 텍스트와 이미지 등과 같은 리소스를 필요하다고 요구하는 쪽이고 서버는 이러한 리소스를 제공하는 쪽HTTP로 통신을 하는 경우 한 번 통신을 할 때 마다 어느 한 쪽은 클라이언트가 되고 다른 한 쪽은 서버가 됨 → HTTP는 클라이언트와 서버를 명확하게 구별하고 있음

HTTP는 클라이언트로부터 request가 송신되면 그 결과가 서버로부터 reponse로 돌아옴 즉슨, 반드시 클라이언트로부터 통신이 시작됨

### 1. stateless

HTTP는 상태를 계속 유지하지 않는 stateless 프로토콜로 리퀘스트와 리스폰스를 교환하는 동안에 상태를 관리하지 않음 → 결국 HTTP 프로토콜 레벨에서는 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해서 기억 Xstateless인 이유는 많은 데이터를 매우 빠르고 확실하게 처리하는 범위성을 확보하기 위함임

그러나 점점 발전해가면서 상태를 유지할 필요성이 생김ex. 쇼핑 사이트에 로그인했을 때 다른 페이지로 이동하더라도 로그인 상태를 유지할 필요가 있음 따라서 Cookie라는 기술이 도입됨

### 2. URI로 리소스 식별

HTTP는 URI를 사용하여 인터넷 상의 리소스를 지정함클라이언트는 리소스를 호출하기 위해 리퀘스트를 송신할 때 리퀘스트 안에 URI를 리퀘스트 URI라 불리는 형식으로 포함해야 함 (방법은 ㅂㄹ.. 안 봐도 될듯!)

### 3. HTTP 메소드
| 메소드 | 설명 |
| --- | --- |
| GET | 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구하는 메소드 |
| POST | 엔티티를 전송하기 위해 사용 |
| PUT | 파일 전송 목적, 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구 |
| HEAD | 메시지 헤더 취득 목적, GET과 같은 기능이지만 메시지 바디는 돌려주지 않음, URI 유효성과 리소스 갱신 시간을 확인하는 목적 등으로 사용됨 |
| DELETE | 파일 삭제 목적, 그러나 HTTP/1.1의 DELETE 자체에는 PUT 메소드와 같이 인증 기능이 없기 때문에 일반적인 웹 사이트에서는 사용되고 있지 않음 |

그 외에도 OPTIONS, TRACE, CONNECT, LINK, UNLINK 등이 있음

### 4. 지속 연결

HTTP 초기 버전에서는 HTTP 통신을 한 번 할 때마다 TCP에 의해 연결 종료를 할 필요가 있었음 뭐 하나 요청을 할 때마다 < TCP 커넥션 연결 → 리소스 → TCP 커넥션 종료 > 이 작업을 무한 반복했었음 한 페이지에서 요청하는 리소스가 많아지면 많아질 수록 매번 TCP 연결과 종료를 하게 되는 일이 발생해 통신량이 늘어나게 됨 → 따라서 지속 연결이 고안됨

지속 연결의 특징은 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지하게 됨지속 연결의 장점은 TCP 연결 종료에 드는 오버헤드를 줄여주어 서버에 대한 부하가 경감됨

### 5. 파이프라인화

지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인화(HTTP pipelining)를 가능하게 함여러 개의 요청은 응답이 도착하기 전까지 큐에 쌓임. 첫 번째 요청이 네트워크를 통해 서버로 전달되면 두 번째 세 번째 요청도 차례로 전달됨 → 대기 시간이 긴 네트워크 상황에서 굳이 리스폰스가 도착할 때까지 기다리지 않아도 되어 네트워크상의 왕복으로 인한 시간을 줄여서 성능을 높여줌

### 6. 쿠키 

stateless protocol도 상태를 유지하지 않는다는 점에서 서버의 CPU나 메모리 같은 리소스 소비를 억제한다는 점에서 장점이 있기는 함. 그럼에도 불구하고 저장해야 될 정보가 분명히 존재하기 때문에 쿠키를 사용!

쿠키는 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템쿠키는 서버에서 리스폰스로 보내진 Set-Cookie라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 됨 → 다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때 자동으로 쿠키 값을 넣어서 송신함 → 그러면 서버는 클라이언트가 보내온 쿠키를 확인하여 어느 클라이언트가 접속했는지 체크하고 서버 상의 기록을 확인하여 이전 상태를 알 수 있음

### **1. HTTP의 취약점**

- 평문(암호화하지 않은) 통신이기 때문에 도청 가능
    - HTTP를 사용한 리퀘스트, 리스폰스 통신 내용은 HTTP 자신을 암호화하는 기능은 없기 때문에 통신 전체가 암호화 되지는 않음
    - TCP/IP 구조의 통신 내용은 전부 통신 경로에서 엿볼 수 있음 ← 패킷 캡처나 스니퍼 툴을 사용해서 네트워크를 흐르고 있는 패킷을 수집하는 것만으로 도청이 가능함
- 통신 상대를 확인하지 않기 때문에 위장 가능
    - HTTP를 사용한 리퀘스트, 리스폰스에서는 통신 상대를 확인하지 않음
    - HTTP는 상대가 누구인지 확인하는 처리는 없기에 누구든지 리퀘스트를 보낼 수 있고 리퀘스트가 오면 누구든지 무언가에게 리스폰스를 반환함. 그러나 상대를 확인하지 않는 점이 악용될 수 있음
- 완전성을 증명할 수 없기 때문에 변조 가능
    - 리퀘스트나 리스폰스가 발신된 후에 상대가 수신할 때까지의 사이에 변조되었다고 하더라도 이 사실을 알 수 없다는 의미 (발신된 리퀘스트나 리스폰스와 수신한 리퀘스트, 리스폰스가 동일한 것인지 증명할 수 없다는 의미)
    - 

### **2. 평문 취약점 → 암호화**

### **a. 통신 암호화**

HTTP에는 암호화 구조가 없지만 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)라는 다른 프로토콜을 조합하여 HTTP의 통신 내용을 암호화할 수 있음 → SSL을 이용해 안전한 통신로를 확보한 후 그 통신로를 사용해 HTTP 통신을 함 → HTTPS(HTTP Secure), HTTP over SSL이라고 불림

### **b. 콘텐츠 암호화**

다른 한 가지는 통신하고 있는 콘텐츠의 내용 자체를 암호화해버리는 방법 HTTP를 암호화하지 않고 HTTP를 사용해서 운반하는 내용을 암호화하는 것 (HTTP 메시지에 포함되는 컨텐츠만 암호화)→ 클라이언트에서 HTTP 메시지를 암호화하는 작업이 필요함그러나 이 콘텐츠 암호화를 유효하게 하기 위해서는 클라이언트와 서버가 콘텐츠의 암호화나 복호화 구조를 가지고 있어야 하므로 일반 유저의 브라우저에서 사용하기에는 어려움

### **3. 위장 가능 → 증명서**

HTTP에서는 통신 상대를 확인할 수 없지만 SSL로 상대를 확인할 수 있음 SSL은 암호화 뿐 아니라 상대를 확인하는 수단으로 증명서를 제공함증명서는 신뢰할 수 있는 제3자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명하고 위조가 굉장히 어려움 → 따라서 통신 상대의 서버나 클라이언트가 가진 증명서를 확인해 통신 상대가 내가 통신하고자 하는 올바른 상대인지 판단할 수 있음

### **4. 변조 가능성을 막기**

가장 많이 사용되는 방법은 MD5, SHA-1, 디지털 서명 등의 방법임그러나 확실히 방지하기 위해서는 HTTPS를 사용해야함. 왜냐하면 SSL에는 인증이나 암호화, 다이제스트 기능을 사용하기 때문임

### **5. HTTPS**

> HTTP에 암호화나 인증 등의 구조를 더한 것을 HTTPS(HTTP Secure)라고 부름 HTTPS = HTTP + 통신의 암호화 + 증명서 + 완전성 보호HTTPS를 사용하는 통신은 URI에 http:// 대신 https:// 사용
> 

### **HTTPS 프로토콜**

`HTTPS`는 새로운 애플리케이션 계층의 프로토콜이 아닌 `HTTP` 통신을 하는 소켓을 `SSL`(Secure Socket Layer)이나 `TLS`(Transport Layer Security) 프로토콜로 대체하고 있는 것임 따라서 `HTTP`는 직접 `TCP`와 통신하지만 `SSL`을 사용한 `HTTP`는 `SSL`과 통신하고 `SSL`이 `TCP`와 통신하게 됨

`SSL`은 `HTTP`와 독립된 프로토콜로 `SSL`은 현재 세계 어느 곳에서도 널리 사용 되고 있는 네트워크 보안 기술임
