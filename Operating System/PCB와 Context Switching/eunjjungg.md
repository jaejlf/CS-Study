# 1. Process Metadata

- 프로세스가 생성되면 PCB(Process Control Block)에 프로세스 메타데이터가 담김
- 프로세스 메타데이터의 정보
    - Process ID : PID, 프로세스 고유 식별 번호
    - Process State : 프로세스의 현재 상태(준비, 실행, 대기)를 기억함
    - Process Priority : 프로세스 우선순위 등과 같은 스케줄링 관련 정보를 기억함
    - CPU Registers : 프로세스의 레지스터 상태를 저장하는 공간
    - Owner : 계정 정보
    - 기억장치 관리 정보 : CPU 사용시간의 정보, 각종 스케줄러에 필요한 정보를 기억시킴
    - 입출력 정보 : 프로세스 수행 시 필요한 주변 장치, 파일들의 정보를 기억
    - 프로그램 카운터 : 다음 실행되는 명령어의 주소를 기억
    
<br/><br/>

# 2. PCB

- 프로세스의 메타데이터들을 저장해 놓는 곳
- 하나의 PCB 안에는 하나의 프로세스의 정보가 담겨짐
- 저장 루트 : 프로그램 실행 → 프로세스 생성 → 프로세스 주소 공간에 코드, 데이터, 스택 생성 → 이 프로세스의 메타데이터가 PCB에 저장

<br/>

**목적**

- CPU에서는 프로세스의 상태에 따라 교체 작업이 이뤄지는데 작업이 끝난 후 다시 수행할 Block 상태의 프로세스의 상태값을 PCB에 저장하는 것

<br/>

**관리 방식**

- Linked List 방식으로 관리됨
    - PCB List Head에 PCB들이 생성될 때마다 추가 → 삽입 삭제가 용이
    - 프로세스가 생성될 때 PCB가 생성되고 프로세스 완료 시 제거됨
    

<br/><br/>

# 3. Context Switching

> 수행 중이던 프로세스를 변경할 때 CPU의 레지스터 정보가 변경되는 것 <br/>
CPU가 현재 실행하고 있는 Task의 상태를 저장하고 다음 진행할 Task의 상태 및 Register 값들에 대한 정보를 읽어 새로운 Task의 Context 정보로 교체<br/>
Interrupt가 일어나면 Context Switching이 발생
> 

<br/>

**동작 과정**

1. Task의 대부분 정보들이 Register에 저장되고 PCB로 관리됨 
2. 현재 실행하고 있던 Task의 PCB 정보를 저장함
3. 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 하던 작업들을 연속적으로 수행할 수 있음 

<br/>

**Cost**

> 프로세스가 스레드보다 더 많이 듦. <br/>
Thread는 Stack을 제외하고 메모리를 공유하기에 Stack 영역만 변경하면 됨<br/>
> 
1. 캐시 초기화 
2. 메모리 매핑 초기화
3. 메모리의 접근을 위해 커널이 항상 실행되어야 함 

→ 잦은 Context Switching은 성능 저하를 가져옴
