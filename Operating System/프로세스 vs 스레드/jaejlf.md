# 📍 프로그램

  -  어떤 작업을 위해 실행할 수 있는 파일
  -  명령어, 코드 등 정적인 데이터의 묶음
  -  파일이 저장 장치에 저장되어 있지만 메모리에는 올라가 있지 않은 상태

<br><br>

# 📍 프로세스

- 실행 중인 프로그램
- 운영체제로부터 시스템 자원을 할당받는 작업의 단위
- 프로그램을 실행하면 운영체제로부터 실행에 필요한 자원을 할당받아 `프로세스`가 된다.
- 프로세스가 할당받는 시스템 자원 : CPU 시간, 주소 공간, 메모리 영역 등

<br>

💡 프로세서 (Processor) = 프로세스를 실행할 수 있도록 하는 하드웨어 (ex. CPU)

<br>

## 특징

- 프로세스는  `Code, Data, Stack, Heap`의 구조로 되어있는 독립된 메모리 영역을 할당받는다.
- 각 프로세스는 `독립적`이다.
  - 각 프로세스는 별도의 주소 공간에서 실행된다.
  - 서로 독자적인 메모리 공간을 갖기 때문에, 메모리 공간을 공유할 수 없다. 즉, 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
- `IPC(Inter-Process Communication, 프로세스 간 통신)`를 사용해 통신한다.

<br>

## 관련 개념

### 프로세스의 구조

<img src = "https://user-images.githubusercontent.com/78673570/183251382-120fbe9e-20c2-49d6-b036-fd345df672d6.png" width = "40%">

<br>

### 프로세스의 상태 변화

![image](https://user-images.githubusercontent.com/78673570/183251021-5ea8edec-6005-40e3-8a07-4a58660d13d0.png)

- `생성` : 처음 작업이 시스템에 주어진 상태
- `준비` : 실행 준비가 되어 CPU 할당을 기다리는 상태
- `실행` : 프로세스가 처리되는 상태
- `종료` : 모든 처리가 완료되어 사용자에게 반환되는 상태
- `대기` : 프로세스가 특정 자원을 할당받을 때까지 또는 입출력(I/O) 작업이 끝날 때까지 작업이 보류되는 상태
- `디스패치(Dispatch)` : 준비 단계에서 실행 단계로 가는 과정
- `Timeout` : 할당 시간 만료
- `Wake Up` : 재개 조건 만족
- `Block` : 이벤트 대기

<br>

### PCB (Process Control Block)

![image](https://user-images.githubusercontent.com/78673570/183253883-6d6ed897-a28c-4039-a14e-755d8084df47.png)

- 프로세스 제어 블럭
- 프로세스의 제어를 위한 정보를 포함하고 있는 자료구조
- 운영체제가 프로세스 스케쥴링을 위한 정보를 가지고 있는 것
- 프로세스가 생성될 때마다 공유의 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거된다.
- PCB에 들어있는 정보
  1. `포인터` : 프로세스의 현재 위치를 저장하는 포인터 정보
  2. `프로세스 상태` : 프로세스의 각 상태(생성/준비/실행/대기/종료)
  3. `프로세스 번호` : 모든 프로세스에는 프로세스 식별자를 지정하는 고유한 ID(= PID)
  4. `프로그램 카운터` : 프로세스를 위해 실행될 다음 명령어의 주소를 포함하는 카운터
  5. `레지스터` : CPU 레지스터에 있는 정보
  6. `메모리 제한` : 운영체제에서 사용하는 메모리 관리 시스템에 대한 정보 (페이지 테이블, 세그먼트 테이블 등)
  7. `열린 파일 목록` : 프로세스를 위해 열린 파일 목록

<br><br>

# 📍 스레드

- 프로세스가 할당받는 자원을 이용하는 실행 단위
- 프로세스의 특정한 수행 경로
- 프로세스 내에서 실행되는 여러 작업 흐름의 단위
- 프로세스가 운영체제로부터 자원을 할당받으면 그 자원을 스레드가 사용하여 실제로 작업을 수행한다.
- 프로세스는 최소 한 개 이상의 스레드를 가지며, 이 스레드를 메인 스레드(main thread)라고 한다.

<br>

## 특징

- 각 스레드는 `독립적인 스택(Stack) 메모리`를 갖는다.
- 스레드는 프로세스 내에서 각각의 스택만 할당받고, `Code, Data, Heap 영역은 공유`한다.
- 스레드는 메모리를 공유하기 때문에 동기화, 데드락 등의 문제가 발생할 수 있다.

<br><br>

# 📍 멀티 프로세싱 vs 멀티 스레딩

## 멀티 프로세싱

- 하나의 프로그램을 여러 개의 프로세스로 구성하여, 각 프로세스가 하나의 작업을 처리하도록 하는 것
- 특징
  - `각 프로세스는 독립적이다.`
    - 여러 개의 자식 프로세스 중 하나에 문제가 발생하더라도, 다른 프로세스들에 영향을 주지 않는다.
    - 동기화 작업이 필요하지 않다.
    - 자원이 소모적이고 개별 메모리를 차지한다.
    - IPC를 사용한 통신 기법으로 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에, 프로세스 사이의 변수나 자료구조를 공유할 수 없다.
  - `Context Switching 비용이 크다`
    - Context Switching 이 발생하면 캐시의 모든 데이터를 리셋하고 다시 캐시 정보를 불러와야하기 때문에 무거운 작업이 진행되고 많은 시간이 소모된다.

<br>

### 프로세스의 동시성 vs 병렬성

![image](https://user-images.githubusercontent.com/78673570/183253705-b79ed867-cbd1-4edc-9594-c97aaf8eab8a.png)

동시성(Concurrency) | 병렬성(Parallelism)
-- | --
동시에 실행되는 것 같이 "보이도록" 처리하는 것 | "실제로 동시에" 여러 작업이 처리되는 것
싱글 코어에서 멀티 스레드를 동작 시키는 방식 | 멀티 코어에서 멀티 스레드를 동작시키는 것 

<br>

## 멀티 스레딩

- 하나의 프로세스를 여러 개의 실행 단위로 나누어, 동시에 여러 개의 일을 수행할 수 있도록 하는 것
- 특징
  - `각 스레드는 긴밀하게 연결되어 있다.`
    - 자원을 공유하기 때문에 자원을 효율적으로 관리할 수 있다.
    - 스택 영역을 제외한 모든 메모리를 공유하기 때문에, 통신의 부담이 적고 시스템 자원 소모가 줄어든다.
    - 공유되는 자원을 관리해주어야한다. 
    - 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.
   - `Context Switching 비용이 작다.`
    - 스레드 사이의 작업량이 작아 Context Switching 이 빠르다. 

<br>

### 동기화 & 데드락 문제

멀티 스레드 환경에서 스레드는 `스택 영역을 제외한 모든 메모리를 공유`하기 때문에 동기화, 데드락 문제가 발생할 수 있다. 

(동기화 & 데드락 ... )
