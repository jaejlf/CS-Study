# 📍 레디스 (Redis)

![image](https://user-images.githubusercontent.com/78673570/196022992-28fe8986-d6ed-4d36-913f-021ed3088076.png)

- Key, Value 구조의 비정형 데이터를 저장하고 관리하기 위한 오픈 소스 기반의 비관계형 데이터 베이스 관리 시스템
- 데이터베이스, 캐시, 메세지 브로커로 사용되며 인메모리 데이터 구조를 가진 저장소

<br>

## 특징
- 영속성을 지원
- 모든 데이터를 메모리에 저장하고 조회하기때문에 빠른 Read, Write 속도를 보장
- 여러 자료구조를 지원 : String, Set, Sorted Set, Hash, List 등 -> 개발의 편의성이 좋아지고 난이도가 낮아진다.
- 서버 복제 지원
  - Master - slave 구조로, 여러개의 복제본을 만들 수 있다.
  - 데이터베이스 읽기를 확장할 수 있기 때문에 높은 가용성(오랜 시간동안 고장나지 않음) 클러스터를 제공한다.
- 트랜잭션 기능 지원
- Pub/Sub 메세징
  - Publish(발행)과 Sub(구독)방식의 메시지를 패턴 검색이 가능하여, 따라서 높은 성능을 요구하는 채팅, 실시간 스트리밍, SNS 피드 그리고 서버상호통신에 사용할 수 있다.
- 싱글스레드 : 1번에 1개의 명령어만 실행할 수 있다.

<br>

## Redis의 영속성
레디스는 데이터를 디스크에 저장하지 않고, 메모리에 저장한다. 이와 비슷한 memcached의 경우, 전원이 꺼지면 데이터가 사라지는 반면 레디스는 그렇지 않다.

<br>

### snapshotting(RDB) 방식
- 순간적으로 메모리에 있는 내용을 디스크에 옮기는 방식
  - `SAVE 방식` : SAVE는 순간적으로 redis의 동작을 정지시키고 그 snapshot를 디스크에 저장 (blocking 방식) 
  - `BGSAVE 방식` : 별도의 프로세스를 띄운 후, 명령어 수행 당시의 snapshot을 disk에 저장하고 redis는 동작을 멈추지 않는다. (non-blocking 방식)

<br>

### AOF 방식
- redis의 write/update 연산을 log파일에 기록하여, 서버가 재시작될 때 log에 기록된 write/update 연산을 재실행하여 데이터를 복구하는 방식
  - 장점 : log 파일에 대해서만 append하기 때문에 log write 속도가 빠르고 어떤 시점에 서버가 다운되더라도 데이터가 사라지지 않는다.
  - 단점 : write/update 연산을 log파일에 남기기 때문에 log데이터 양이 굉장히 크고, 복구 시 저장된 모든 write/update연산을 다시 실행하기 때문에 재시작 속도가 느리다.

<br>

## 활용 - 캐싱 전략 (= Lazy Loading)
캐시를 옆에 두고, 필요할 때만 데이터를 캐시에 로드하는 전략

![image](https://user-images.githubusercontent.com/78673570/196023094-c45dc196-33c8-41c1-a1e4-2de32bffad9f.png)

1. 데이터 요청
2. 레디스에 데이터가 있다면 바로 반환
3. 없다면 데이터베이스에 데이터 요청
4. 이 데이터를 레디스에 저장
