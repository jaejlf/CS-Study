# 1. 저장 프로시저

> 저장 프로시저 또는 스토어드 프로시저는 일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합.
> 

저장 프로시저는 쿼리문들의 집합으로 어떤 동작을 여러 쿼리를 거쳐서 일괄적으로 처리할 때 사용함. 

<br/>

**장점**

- SQL 서버의 성능을 향상시킬 수 있음.
    - 저장 프로시저를 처음 실행하면 최적화, 컴파일 단계를 거쳐 그 결과가 캐시에 저장되는데 이후 저장 프로시저를 실행하면 캐시를 사용하므로 속도가 빨라지게 됨.
- 유지보수 및 재활용 측면에서 좋음.
    - 개발자가 수정요건이 발생했을 때 코드 내 SQL들을 하나하나 찾아서 수정해주는 것이 아닌 저장 프로시저 코드 파일만 수정하면 되기에 유지보수 측면에서 유리함.
- 보안을 강화할 수 있음.
    - 사용자별로 테이블에 권한을 주는게 아니고 저장 프로시저에만 권한을 주는 방식으로 보안을 강화할 수 있음.
- 네트워크 부하를 줄일 수 있음.
    - 클라이언트에서 서버로 쿼리의 모든 텍스트가 전송될 경우 네트워크에는 큰 부하가 발생하게 됨. 하지만 저장 프로시저로 이름, 매개변수 등 적은 글자만 전송하면 부하를 크게 줄일 수 있음.

<br/>

**단점**

- 저장 프로시저는 첫 번째 수행 시 최적화가 이루어져 인덱스 기능을 사용할 것인지 말 것인지 결정함. 근데 첫 번째 수행 때 아주 적은 데이터 건수만 가져오도록 파라미터가 설정되어 있다면 인덱스 기능을 사용하도록 최적화되어 컴파일 됨. 그러나 두 번째부터 많은 건수의 데이터를 가져오도록 컴파일 된다면 성능에 크게 문제가 발생할 것임. → 다시 컴파일해주는 과정이 필요함.

<br/><br/>

# 2. 동작 과정

<br/>

### a. 일반 SQL 동작 방식

`SQL 정의 시`

![image](https://user-images.githubusercontent.com/100047095/196027734-3d3c2006-a800-4f7b-a879-e83cf27b9da6.png)

- 구문 분석 : 구문 자체에 오류가 있는지 없는지 검사하는 단계
- 개체 이름 확인 : 쿼리를 실행하는 테이블이 현재 데이터베이스에 있는지 확인하는 단계.
- 사용 권한 확인 : 접근중인 사용자가 이 테이블에 대해 권한이 있는지 확인
- 최적화 : 인덱스 사용 여부에 따라 쿼리문이 가장 좋은 성능을 낼 수 있는 경로를 확인

<br/>

`SQL 실행 시 (첫 번째 이후)`

![image](https://user-images.githubusercontent.com/100047095/196027749-9c14ac0b-9cea-4aca-83ae-62898e5e1e39.png)

- 동일한 쿼리가 있다면 캐시를 통해 빠르게 작동이 되는데 단 조건은 쿼리 전체가 한 글자도 빼놓지 않고 같아야 함.

<br/>

### b. 저장 프로시저 동작 방식

`저장 프로시저 정의 시`

![image](https://user-images.githubusercontent.com/100047095/196027759-f2f1d7ac-7016-4546-bc76-4a94bc3f40cb.png)

- 지연된 이름 확인 : 저장 프로시저는 이를 정의하는 시점에 테이블과 같은 해당 개체의 존재여부와 상관 없이 정의가 가능함. 왜냐하면 해당 테이블의 존재 여부를 프로시저 실행 시점에 확인하기 때문.

<br/>

`저장 프로시저 실행 시 (첫 번째 이후)`

![image](https://user-images.githubusercontent.com/100047095/196027764-e9fe8691-6287-43ae-9367-469e45223b1a.png)

- 일반 SQL과 다른 점은 일반 SQL은 이전에 실행된 쿼리와 한 글자도 빼놓지 않고 같을 때 캐시를 사용하지만 저장 프로시저는 매개변수만 다른 정도면 캐시를 확인해서 속도를 단축할 수 있음.
